<!doctype html>
<html lang="en" class="h-full bg-background">

<head>
  <meta charset="utf-8" />
  <title>BizShuffle Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <script>
    // Global sleep helper: await sleep(ms)
    window.sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    tailwind.config = {
      theme: {
        extend: {
          colors: { background: "#0f1724", card: "#071122" },
        },
      },
    };
  </script>
  <style>
    [draggable="true"] {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    [draggable="true"] * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* Prevent number width jitter by using tabular numbers */
    .numeric {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum";
    }

    /* Stable button sizing to avoid layout shift when swapping text/spinners */
    .btn-stable {
      width: 10rem;
      height: 2.25rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
  </style>
  <script defer src="https://unpkg.com/alpinejs@3.12.0/dist/cdn.min.js"></script>
</head>

<body x-data="app()" x-init="init()" class="text-white font-inter h-full flex flex-col">
  <!-- Top swap progress bar: thin indicator that fills to the right until next swap -->
  <div class="fixed top-0 left-0 w-full h-1 z-50 pointer-events-none">
    <div x-show="state.next_swap_at" class="h-full bg-white/10 w-full">
      <!-- Use GPU-accelerated transform scaleX for smooth continuous updates -->
      <div id="swap-progress" class="h-full origin-left" :style="'transform: scaleX(' + (swapProgressPercent / 100) + ')'
          " style="transform-origin:left; will-change:transform; background-color: rgba(52,211,153,1);"
        x-bind:class="(swapProgressPercent >= 95 ? 'bg-amber-400' : 'bg-green-400')"></div>
    </div>
  </div>
  <!-- Main -->
  <main class="mx-auto px-6 py-8 flex-1 grid gap-6 lg:grid-cols-3">
    <!-- Sidebar (Session, Games, Saves) -->
    <!-- changed to flex column so expanded accordion panels can grow to fill available vertical space -->
    <div class="flex flex-col gap-6 h-full">
      <!-- Session -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <div class="flex justify-between items-center">
          <div>
            <p class="text-sm text-gray-400">Session</p>
            <p class="text-lg font-bold inline-block min-w-[6.5rem]"
              :class="state.running ? 'text-green-400' : 'text-red-400'" x-text="state.running ? 'Running' : 'Stopped'">
            </p>
            <p class="text-xs text-gray-500" x-text="'Updated: ' + lastUpdated"></p>
          </div>
          <div class="text-right">
            <p class="text-sm text-gray-400">Next swap</p>
            <p class="text-lg font-bold numeric inline-block min-w-[8ch] text-right" x-text="nextSwapDisplay"></p>
          </div>
        </div>

        <div class="mt-3">
          <label class="block text-sm text-gray-300 mb-1">Mode</label>
          <select x-model="state.mode" @change="setMode(state.mode)" class="px-2 py-1 rounded bg-slate-700">
            <option value="sync">Sync swap (all same game)</option>
            <option value="save">Save swap (per-player saves)</option>
          </select>
        </div>

        <div class="mt-4 flex flex-wrap gap-2">
          <template x-for="btn in sessionButtons" :key="btn.label">
            <button @click="trigger(btn.path)" class="px-1 py-1 rounded font-semibold transition btn-stable"
              :class="getButtonClass(btn)" :title="getButtonTitle(btn)">
              <span class="inline-flex items-center gap-2 justify-center w-full">
                <span x-text="btn.label"></span>
                <!-- small On/Off badge for the Toggle Swaps button -->
                <template x-if="btn.path === '/api/toggle_swaps'">
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="state.swap_enabled ? 'bg-white/90 text-black' : 'bg-slate-800 text-gray-300'"
                    x-text="state.swap_enabled ? 'On' : 'Off'"></span>
                </template>
                <!-- small On/Off badge for the Prevent Same Game button -->
                <template x-if="btn.path === '/api/toggle_prevent_same_game'">
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="state.prevent_same_game_swap ? 'bg-white/90 text-black' : 'bg-slate-800 text-gray-300'"
                    x-text="state.prevent_same_game_swap ? 'On' : 'Off'"></span>
                </template>
              </span>
            </button>
          </template>
        </div>

        <!-- Interval -->
        <div class="mt-6">
          <label class="block text-sm text-gray-300 mb-1">Swap interval (secs)</label>
          <p class="text-sm text-gray-400 mb-2 numeric" x-text="intervalDisplay"></p>

          <div class="flex flex-wrap items-center gap-3">
            <input x-model.number="interval.min" type="number" placeholder="min"
              class="w-24 px-2 py-1 rounded bg-transparent border border-white/20 text-white numeric" />
            <input x-model.number="interval.max" type="number" placeholder="max"
              class="w-24 px-2 py-1 rounded bg-transparent border border-white/20 text-white numeric" />
            <button @click="saveInterval()" :disabled="!intervalValid"
              class="px-4 py-1 rounded font-semibold transition"
              :class="intervalValid ? 'bg-slate-700 hover:bg-slate-600' : 'bg-slate-800 text-gray-500 cursor-not-allowed'">
              Save
            </button>
          </div>
          <p class="text-xs text-red-400 mt-2" x-show="intervalError" x-text="intervalError"></p>
        </div>
      </section>
    </div>

    <div class="space-y-6 col-span-2">
      <!-- Players -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <div class="flex justify-between items-center mb-3">
          <div>
            <h2 class="text-sm text-gray-400">Players</h2>
            <p class="text-xs text-gray-500">
              Connected clients & current game
            </p>
          </div>
          <div class="flex gap-2">
            <button @click="messageAll()" class="px-3 py-1 rounded bg-blue-600 hover:bg-blue-500">
              Message All
            </button>
            <button @click="refreshState()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Refresh
            </button>
          </div>
        </div>
        <ul class="space-y-2">
          <template x-for="(p, name) in state.players" :key="name">
            <li
              class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 bg-slate-800/40 p-3 rounded hover:bg-slate-700/40 transition-all"
              draggable="true" @dragstart="onDragStart($event, name, 'player')" @dragend="onDragEnd($event)">
              <!-- Left side: player info -->
              <div class="flex-1 min-w-0">
                <div class="flex items-baseline gap-3">
                  <strong class="truncate max-w-[10rem] sm:max-w-[14rem] select-none flex items-center gap-1"
                    x-text="name">
                    <svg class="w-3 h-3 text-gray-400 opacity-50" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                    </svg>
                  </strong>
                  <div class="text-xs text-gray-400 truncate" x-text="p.game || '-'"></div>
                  <div class="text-xs text-gray-400 truncate" x-text="p.instance_id || '-'"></div>
                </div>

                <div class="mt-1 flex flex-wrap items-center gap-2">
                  <span class="text-xs px-2 py-0.5 rounded-full"
                    :class="p.connected ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'"
                    x-text="p.connected ? 'Connected' : 'Offline'"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full"
                    :class="p.has_files ? 'bg-green-600/10 text-green-300' : 'bg-yellow-600/10 text-yellow-300'"
                    x-text="p.has_files ? 'Has files' : 'Missing files'"></span>
                  <span class="text-xs text-gray-400"
                    x-text="p.ping_ms ? ('ping: ' + p.ping_ms + 'ms') : 'No ping'"></span>
                </div>
              </div>

              <!-- Right side: controls -->
              <div class="flex items-center gap-2 min-w-0">
                <!-- If in sync mode, let user pick a game; otherwise pick an instance -->
                <template x-if="state.mode === 'sync'">
                  <select x-model="p.selectedGame" class="bg-slate-700 rounded text-sm max-w-[12rem] truncate">
                    <option value="">-- select game --</option>
                    <template x-for="g in state.games" :key="g">
                      <option :value="g" x-text="g"></option>
                    </template>
                  </select>
                </template>
                <template x-if="state.mode !== 'sync'">
                  <select x-model="p.selectedGame" class="bg-slate-700 rounded text-sm max-w-[12rem] truncate">
                    <option value="">-- select instance --</option>
                    <template x-for="inst in gameInstances" :key="inst.id">
                      <option :value="inst.id" x-text="inst.id + ' — ' + inst.game"></option>
                    </template>
                  </select>
                </template>

                <button @click="swapPlayer(name, p.selectedGame)"
                  class="px-2 py-1 rounded text-xs font-semibold transition whitespace-nowrap"
                  :class="p.selectedGame ? 'bg-slate-700 hover:bg-slate-600' : 'bg-slate-800 text-gray-500 cursor-not-allowed'">
                  Swap
                </button>
                <button @click="randomSwap(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-emerald-500 hover:bg-emerald-400 text-black">
                  Random
                </button>
                <button @click="messagePlayer(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-blue-600 hover:bg-blue-500">
                  Message
                </button>
                <button @click="removePlayer(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-red-600 hover:bg-red-500">
                  Remove
                </button>
              </div>
            </li>
          </template>
        </ul>
      </section>

      <!-- Games -->
      <template x-if="state.mode === 'sync'">
        <section
          :class="showGamesExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
          class="transition-all">
          <div class="flex justify-between items-center">
            <h2 class="text-sm text-gray-400">Games</h2>
            <button @click="toggleSection('games')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
              <span x-text="showGamesExpanded ? 'Collapse' : 'Expand'"></span>
            </button>
            <button @click="showCatalog = true" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Catalog
            </button>
            <button @click="setupGameMode()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Auto Setup
            </button>
          </div>
          <!-- Saved instances list -->
          <div
            :class="showGamesExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-60 overflow-auto'">
            <!-- If sync mode, show list of available games with a Swap All button -->
            <template x-for="(g, idx) in mainGamesList" :key="g">
              <div class="flex justify-between items-center bg-slate-800/40 p-2 rounded">
                <div class="flex items-center gap-3">
                  <input type="checkbox" :id="'sync-game-'+idx" :value="g" x-bind:checked="state.games.includes(g)"
                    @change="toggleSyncGame(g, $event.target.checked)" class="w-4 h-4" />
                  <label :for="'sync-game-'+idx" class="text-sm font-mono text-gray-200 truncate" x-text="g"></label>
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold bg-blue-500 text-white"
                    x-show="countPlayersOnGame(g) > 0"
                    x-text="countPlayersOnGame(g) + ' player' + (countPlayersOnGame(g) > 1 ? 's' : '')"></span>
                </div>
                <div class="flex gap-2">
                  <button @click="swapAll(g)"
                    class="text-xs px-2 py-1 rounded bg-emerald-500 hover:bg-emerald-400 text-black">Swap All</button>
                </div>
              </div>
            </template>
          </div>
        </section>
      </template>
      <template x-if="state.mode === 'save'">
        <section
          :class="showGamesExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
          class="transition-all">
          <div class="flex justify-between items-center">
            <h2 class="text-sm text-gray-400">Games</h2>
            <button @click="toggleSection('games')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
              <span x-text="showGamesExpanded ? 'Collapse' : 'Expand'"></span>
            </button>
            <button @click="showCatalog = true" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Catalog
            </button>
            <button @click="setupGameMode()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Auto Setup
            </button>
          </div>
          <!-- Saved instances list -->
          <div
            :class="showGamesExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-60 overflow-auto'">

            <template x-for="(inst, idx) in gameInstances" :key="inst.id">
              <div
                class="flex justify-between items-center bg-slate-800/40 p-2 rounded transition-all hover:bg-slate-700/40 border-2 border-transparent"
                @dragover.prevent="onDragOver($event)" @dragleave="onDragLeave($event)"
                @drop="onDrop($event, inst.id, 'instance')">
                <div class="flex flex-col">
                  <span class="text-sm font-mono text-gray-200" x-text="inst.id"></span>
                  <span class="text-sm text-gray-400" x-text="inst.game || '(no game)'"></span>
                  <div class="flex items-center gap-2">
                    <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                      :class="inst.file_state === 'ready' ? 'bg-green-500/20 text-green-400' : inst.file_state === 'pending' ? 'bg-yellow-500/20 text-yellow-400' : 'bg-gray-500/20 text-gray-400'"
                      x-text="(inst.file_state || 'none') + (inst.pending_player ? ': ' + inst.pending_player : '')">
                    </span>
                    <span class="text-xs text-gray-500" x-text="inst.player ? 'assigned:' : 'unassigned'"></span>
                  </div>
                  <template x-if="inst.player">
                    <span
                      class="px-2 py-1 bg-blue-600/20 text-blue-300 rounded text-xs cursor-move select-none flex items-center gap-1 hover:bg-blue-600/30 transition-colors"
                      draggable="true" @dragstart="onDragStart($event, inst.player, 'player')"
                      @dragend="onDragEnd($event)">
                      <svg class="w-3 h-3 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                        <path
                          d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                      </svg>
                      <span x-text="inst.player"></span>
                    </span>
                  </template>
                </div>
                <div>
                  <button @click="() => { gameInstances.splice(idx,1); saveInstances(); }"
                    class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Remove</button>
                </div>
              </div>
            </template>
          </div>

          <!-- Unassigned Players Drop Zone -->
          <div
            class="mt-4 p-4 border-2 border-dashed border-slate-600 rounded-lg bg-slate-800/20 transition-all hover:bg-slate-700/30 hover:border-slate-500"
            @dragover.prevent="onDragOver($event)" @dragleave="onDragLeave($event)"
            @drop="onDrop($event, null, 'unassigned')">
            <div class="text-center">
              <div class="text-sm text-gray-400 mb-2">Unassigned Players</div>
              <div class="text-xs text-gray-500">Drop players here to unassign them</div>
              <div class="mt-2 flex flex-wrap gap-2 justify-center" x-show="unassignedPlayers.length > 0">
                <template x-for="player in unassignedPlayers" :key="player">
                  <span
                    class="px-2 py-1 bg-slate-700 rounded text-xs cursor-move select-none hover:bg-slate-600 transition-colors flex items-center gap-1"
                    draggable="true" @dragstart="onDragStart($event, player, 'player')" @dragend="onDragEnd($event)">
                    <svg class="w-3 h-3 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                    </svg>
                    <span x-text="player"></span>
                  </span>
                </template>
              </div>
              <div class="text-xs text-gray-500 mt-2" x-show="unassignedPlayers.length === 0">No unassigned players
              </div>
            </div>
          </div>

          <div class="mt-4 p-3 bg-slate-800/40 rounded">
            <h3 class="text-sm text-gray-300 mb-2">Add New Instance</h3>
            <div class="flex items-center gap-2">
              <input class="bg-slate-700 rounded px-2 py-1 text-sm w-48" type="text" placeholder="Instance ID"
                x-model="newInstance.id" />
              <select x-model="newInstance.game" @change="autofillId()"
                class="bg-slate-700 rounded px-2 py-1 text-sm max-w-[12rem]">
                <option value="">-- select file --</option>
                <template x-for="f in mainGamesList" :key="f">
                  <option :value="f" x-text="f"></option>
                </template>
              </select>
              <button @click="addInstance()" class="px-3 py-1 rounded bg-green-600 hover:bg-green-500 text-sm">
                Add
              </button>
            </div>
          </div>
        </section>
      </template>

      <!-- Plugins -->
      <section
        :class="showPluginsExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
        class="transition-all">
        <div class="flex justify-between items-center">
          <h2 class="text-sm text-gray-400">Plugins</h2>
          <button @click="toggleSection('plugins')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
            <span x-text="showPluginsExpanded ? 'Collapse' : 'Expand'"></span>
          </button>
        </div>

        <div
          :class="showPluginsExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-40 overflow-auto'">
          <template x-for="(plugin, name) in plugins" :key="name">
            <div class="flex justify-between items-center bg-slate-800/40 p-2 rounded">
              <div class="flex-1">
                <div class="flex items-center gap-2">
                  <span class="text-sm font-medium" x-text="plugin.name"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="plugin.status === 'enabled' ? 'bg-green-400 text-black' : plugin.status === 'error' ? 'bg-red-400 text-black' : 'bg-slate-600 text-gray-300'"
                    x-text="plugin.status"></span>
                </div>
                <div class="text-xs text-gray-400" x-text="plugin.description || 'No description'"></div>
                <div class="text-xs text-gray-500"
                  x-text="'v' + (plugin.version || '1.0.0') + ' by ' + (plugin.author || 'Unknown')"></div>
              </div>
              <div class="flex gap-1">
                <button @click="togglePlugin(name, plugin.status !== 'enabled')"
                  class="text-xs px-2 py-1 rounded transition-colors"
                  :class="plugin.status === 'enabled' ? 'bg-orange-500 hover:bg-orange-400 text-black' : 'bg-green-500 hover:bg-green-400 text-black'"
                  x-text="plugin.status === 'enabled' ? 'Disable' : 'Enable'">
                </button>
                <button @click="showPluginDetails(name)"
                  class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">Details</button>
                <button @click="deletePlugin(name)"
                  class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Delete</button>
              </div>
            </div>
          </template>

          <div x-show="Object.keys(plugins).length === 0" class="text-sm text-gray-500 text-center py-4">
            No plugins found. Upload a plugin to get started.
          </div>
        </div>

        <div class="mt-3 flex gap-2 items-center">
          <input type="file" id="plugin-upload" accept=".lua" class="hidden" @change="uploadPlugin($event)">
          <button @click="document.getElementById('plugin-upload').click()"
            class="px-3 py-1 rounded bg-blue-600 hover:bg-blue-500 text-sm">
            Upload Plugin
          </button>
          <button @click="refreshPlugins()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm">
            Refresh
          </button>
        </div>
      </section>

      <!-- Plugin Details Modal -->
      <div x-show="pluginDetailsVisible" x-transition
        class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
        <div class="bg-card rounded-lg w-11/12 max-w-2xl p-4">
          <div class="flex justify-between items-center mb-3">
            <h3 class="text-lg font-bold">Plugin: <span x-text="pluginDetails.name"></span></h3>
            <div class="flex gap-2">
              <button @click="pluginDetailsVisible = false"
                class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Close</button>
            </div>
          </div>
          <div class="text-sm text-gray-400 mb-2" x-text="pluginDetails.description"></div>
          <div class="grid grid-cols-2 gap-4">
            <div>
              <div class="text-xs text-gray-400">Version</div>
              <div class="text-sm" x-text="pluginDetails.version || '1.0.0'"></div>
            </div>
            <div>
              <div class="text-xs text-gray-400">Author</div>
              <div class="text-sm" x-text="pluginDetails.author || 'Unknown'"></div>
            </div>
          </div>
          <div class="mt-3">
            <div class="text-xs text-gray-400">Meta JSON</div>
            <pre class="text-xs bg-[#02101a] p-2 rounded mt-1 overflow-auto" x-text="pluginDetails.metaRaw"></pre>
          </div>
        </div>
      </div>

      <!-- Logs -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <h2 class="text-sm text-gray-400">Logs</h2>
        <div class="mt-2 bg-[#02101a] p-3 rounded h-96 overflow-auto text-sm space-y-1">
          <template x-for="log in logs" :key="log.id">
            <div>
              <span class="text-gray-500" x-text="log.time"></span>
              <span class="ml-2" x-text="log.message"></span>
            </div>
          </template>
        </div>
      </section>
    </div>
  </main>

  <!-- Toast -->
  <div x-show="toast" x-transition class="fixed bottom-4 right-4 bg-slate-800 text-white px-4 py-2 rounded shadow"
    x-text="toast"></div>

  <!-- Catalog Modal -->
  <div x-show="showCatalog" x-transition class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-card rounded-lg w-11/12 max-w-3xl p-4">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-bold">Main Games (Catalog)</h3>
        <div class="flex gap-2">
          <button @click="showCatalog = false" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Close</button>
        </div>
      </div>
      <p class="text-xs text-gray-500 mb-2">Catalog of game files and any extra files clients should also download.</p>
      <div class="space-y-2 max-h-72 overflow-auto mb-3">
        <template x-for="(g, idx) in mainGames" :key="idx">
          <div class="bg-slate-800/40 p-2 rounded flex items-start justify-between gap-2">
            <div class="flex-1">
              <div class="text-sm font-medium" x-text="g.file"></div>
              <div class="text-xs text-gray-400"
                x-text="g.extra_files && g.extra_files.length ? ('extra: ' + g.extra_files.join(', ')) : 'no extra files'">
              </div>
            </div>
            <div class="flex gap-2">
              <button @click="removeMainEntry(idx)"
                class="px-2 py-1 rounded bg-red-600 hover:bg-red-500 text-xs">Remove</button>
            </div>
          </div>
        </template>
      </div>

      <div class="border-t border-white/5 pt-3">
        <div class="flex items-center gap-2">
          <div class="flex-1">
            <label class="block text-xs text-gray-400 mb-1">Primary file</label>
            <select x-model="newMain.primary" class="w-full bg-slate-700 rounded px-2 py-1 text-sm">
              <option value="">-- select file --</option>
              <template x-for="f in availableFiles()" :key="f">
                <option :value="f" x-text="f"></option>
              </template>
            </select>
          </div>
          <div class="w-36">
            <label class="block text-xs text-gray-400 mb-1">Extras</label>
            <select x-model="newMain.extras" multiple class="w-full bg-slate-700 rounded px-2 py-1 text-sm">
              <template x-for="f in availableFiles(true)" :key="f">
                <option :value="f" x-text="f"></option>
              </template>
            </select>
          </div>
        </div>
        <div class="mt-2 flex gap-2">
          <button @click="addMainEntry()" :disabled="!newMain.primary"
            class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Add</button>
          <button @click="saveMainGames(); showCatalog = false"
            class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Save Catalog</button>
          <button @click="refreshFilesList()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Refresh
            Files</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Message Composer Modal -->
  <div x-show="showMessageComposer" x-transition
    class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-card rounded-lg w-11/12 max-w-md p-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold">Compose Message</h3>
        <button @click="closeMessageComposer()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">×</button>
      </div>

      <div class="space-y-4">
        <div>
          <label class="block text-sm text-gray-400 mb-1">Message Text</label>
          <textarea x-model="messageComposer.text" class="w-full bg-slate-700 rounded px-2 py-1 text-white resize-none"
            rows="3" placeholder="Enter your message..."></textarea>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Duration (seconds)</label>
            <input x-model.number="messageComposer.duration" type="number" min="1" max="60"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Font Size</label>
            <input x-model.number="messageComposer.fontsize" type="number" min="8" max="48"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">X Position</label>
            <input x-model.number="messageComposer.x" type="number" min="0" max="800"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Y Position</label>
            <input x-model.number="messageComposer.y" type="number" min="0" max="600"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Text Color</label>
            <input x-model="messageComposer.fg" type="color" class="w-full bg-slate-700 rounded px-2 py-1 h-9" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Background Color</label>
            <input x-model="messageComposer.bg" type="color" class="w-full bg-slate-700 rounded px-2 py-1 h-9" />
          </div>
        </div>
      </div>

      <div class="mt-6 flex gap-2 justify-end">
        <button @click="resetMessageComposer()" class="px-4 py-2 rounded bg-gray-600 hover:bg-gray-500">
          Reset
        </button>
        <button @click="closeMessageComposer()" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600">
          Cancel
        </button>
        <button @click="sendComposedMessage()" :disabled="!messageComposer.text.trim()"
          class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 disabled:bg-slate-800 disabled:text-gray-500">
          Send Message
        </button>
      </div>
    </div>
  </div>

  <script>
    function app() {
      return {
        // accordion state: only one of games or saves can be expanded at once
        showGamesExpanded: false,
        showSavesExpanded: false,
        showPluginsExpanded: false,
        loaded: false,
        state: { running: false, games: [], players: {} },
        // UI-managed list of game instances for CRUD
        gameInstances: [],
        newInstance: { id: "", game: "" },
        showCatalog: false,
        // main catalog and available files under /files
        mainGames: [],
        files: [],
        plugins: {},
        // Plugin details modal state
        pluginDetailsVisible: false,
        pluginDetails: {},
        newMain: { primary: "", extras: [] },
        saves: {},
        logs: [],
        interval: { min: null, max: null },
        toast: "",
        selectedGames: [],
        ws: null, // store websocket instance
        // Message composer modal state
        showMessageComposer: false,
        messageComposer: {
          text: "",
          duration: 3,
          x: 10,
          y: 10,
          fontsize: 12,
          fg: "#FFFFFF",
          bg: "#000000"
        },
        messageTarget: null, // 'player' or 'all', and player name if player
        // Drag and drop state
        draggedPlayer: null,
        draggedType: null,
        sessionButtons: [
          { label: "Start", path: "/api/start", class: "bg-green-500 text-black" },
          { label: "Pause", path: "/api/pause", class: "bg-slate-700" },
          { label: "Do Swap", path: "/api/do_swap", class: "bg-slate-700" },
          { label: "Auto Swaps", path: "/api/toggle_swaps", class: "bg-slate-700" },
          { label: "Better Random", path: "/api/toggle_prevent_same_game", class: "bg-slate-700" },
          { label: "Clear Saves", path: "/api/clear_saves", class: "bg-orange-500 text-black" },
        ],
        get lastUpdated() {
          return this.state.updated_at
            ? new Date(this.state.updated_at).toLocaleString()
            : "--";
        },
        get intervalDisplay() {
          return this.state.min_interval_secs && this.state.max_interval_secs
            ? `${this.state.min_interval_secs} - ${this.state.max_interval_secs}`
            : "--";
        },
        // nowMs is kept up-to-date at display refresh rate for smooth animations
        nowMs: Date.now(),
        // legacy second-resolution 'now' for other logic still expecting seconds
        get now() { return Math.floor(this.nowMs / 1000); },
        // percent 0-100 of progress until next swap (0 = just swapped, 100 = swap due)
        get swapProgressPercent() {
          if (!this.state || !this.state.next_swap_at) return 0;
          // Use milliseconds for smoother progress
          const nextMs = this.state.next_swap_at * 1000;
          // Determine interval length in ms. Use max_interval if available else min or default 1s
          const intervalSecs = this.state.max_interval_secs || this.state.min_interval_secs || 1;
          const intervalMs = intervalSecs * 1000;
          const remainingMs = nextMs - this.nowMs;
          if (remainingMs <= 0) return 100;
          const elapsedMs = intervalMs - remainingMs;
          const pct = Math.max(0, Math.min(100, (elapsedMs / intervalMs) * 100));
          return pct;
        },
        get nextSwapDisplay() {
          if (!this.state.next_swap_at) return "--";
          const diff = this.state.next_swap_at - this.now; // seconds until swap
          if (diff <= 0) return "Due";
          // Format as H:MM:SS or M:SS depending on length
          const hrs = Math.floor(diff / 3600);
          const mins = Math.floor((diff % 3600) / 60);
          const secs = diff % 60;
          const pad = (n) => (n < 10 ? '0' + n : '' + n);
          if (hrs > 0) return `${hrs}:${pad(mins)}:${pad(secs)}`;
          return `${mins}:${pad(secs)}`;
        },
        get intervalValid() {
          return (
            this.interval.min > 0 &&
            this.interval.max > 0 &&
            this.interval.min <= this.interval.max
          );
        },
        // unified games list used for displaying file options in the UI.
        get mainGamesList() {
          if (this.mainGames && this.mainGames.length) return this.mainGames.map(e => e.file).filter(Boolean);
          return [];
        },
        get intervalError() {
          if (!this.interval.min || !this.interval.max)
            return "Both values required";
          if (this.interval.min <= 0 || this.interval.max <= 0)
            return "Values must be positive";
          if (this.interval.min > this.interval.max)
            return "Min cannot be greater than Max";
          return "";
        },
        // Computed property for unassigned players
        get unassignedPlayers() {
          const assignedPlayers = new Set();
          for (const inst of this.gameInstances) {
            if (inst.player) assignedPlayers.add(inst.player);
          }
          return Object.keys(this.state.players || {}).filter(player => !assignedPlayers.has(player));
        },
        countPlayersOnGame(game) {
          return Object.values(this.state.players || {}).filter(p => p.game === game).length;
        },
        getButtonClass(btn) {
          if (btn.path === '/api/toggle_swaps') {
            return this.state.swap_enabled ? 'bg-emerald-400 text-black shadow-lg' : 'bg-slate-700';
          } else if (btn.path === '/api/toggle_prevent_same_game') {
            return this.state.prevent_same_game_swap ? 'bg-blue-500 text-white shadow-lg' : 'bg-slate-700';
          } else {
            return btn.class;
          }
        },
        getButtonTitle(btn) {
          if (btn.path === '/api/toggle_swaps') {
            return this.state.swap_enabled ? 'Swaps enabled' : 'Swaps disabled';
          } else if (btn.path === '/api/toggle_prevent_same_game') {
            return this.state.prevent_same_game_swap ? 'Better Random: ON' : 'Better Random: OFF';
          } else {
            return btn.label;
          }
        },
        async init() {
          if (this.loaded) return;
          this.loaded = true;
          await this.refreshFilesList();
          await this.refreshPlugins();
          this.startWS();
          // load server mode
          await this.refreshState();
          // start a high-resolution animation loop to update nowMs for smooth progress
          const rafTick = () => {
            this.nowMs = Date.now();
            // continue the loop
            // If a swap is due, call pausedRefreshState() once. Use _swapDueHandled
            // to avoid repeated calls while the RAF loop runs at high frequency.
            if (this.state && this.state.next_swap_at && this.nowMs / 1000 >= this.state.next_swap_at) {
              if (!this._swapDueHandled) {
                this._swapDueHandled = true;
              }
            } else {
              // reset the flag when we're not currently past the swap time so
              // the next swap event can trigger the handler again
              this._swapDueHandled = false;
            }
            this._rafId = requestAnimationFrame(rafTick);
          };
          // start the loop
          this._rafId = requestAnimationFrame(rafTick);
          // cleanup on unload
          window.addEventListener('beforeunload', () => {
            if (this._rafId) cancelAnimationFrame(this._rafId);
          });
        },
        log(msg) {
          this.logs.unshift({
            id: Date.now() + Math.random(), // unique key
            time: new Date().toLocaleTimeString(),
            message: msg,
          });
          if (this.logs.length > 200) this.logs.pop();
        },
        async refreshState() {
          try {
            const r = await fetch("/state.json");
            const envelope = await r.json();
            const st = envelope && envelope.state ? envelope.state : envelope;

            // Replace all values directly
            this.state = st || {};
            this.mainGames = (st.main_games || []).map((e) => ({
              file: e.file,
              extra_files: e.extra_files || [],
            }));
            this.gameInstances = st.game_instances || [];

            // Populate player field on game instances based on player.instance_id
            const playerMap = {};
            if (this.state.players) {
              for (const [name, player] of Object.entries(this.state.players)) {
                if (player.instance_id) {
                  playerMap[player.instance_id] = name;
                }
              }
            }
            for (const inst of this.gameInstances) {
              inst.player = playerMap[inst.id] || "";
            }

            this.interval.min = st.min_interval_secs || 0;
            this.interval.max = st.max_interval_secs || 0;
          } catch (e) {
            this.log("state fetch error: " + e.message);
          }
        },
        async setMode(mode) {
          try {
            const res = await fetch('/api/mode', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode }) });
            if (res.ok) {
              this.toast = 'Mode updated';
              setTimeout(() => this.toast = '', 1500);
            }
          } catch (e) {
            this.log('mode set err: ' + e.message);
          }
        },
        async setupGameMode() {
          try {
            const res = await fetch('/api/mode/setup', { method: 'POST' });
            if (res.ok) {
              const contentType = res.headers.get('content-type');
              this.log('Game mode setup completed');
              this.toast = 'Game mode setup completed';
              setTimeout(() => this.toast = '', 2000);
            } else {
              this.log('Game mode setup failed');
              this.toast = 'Game mode setup failed';
              setTimeout(() => this.toast = '', 2000);
            }
          } catch (e) {
            this.log('Game mode setup error: ' + e.message);
            this.toast = 'Game mode setup error';
            setTimeout(() => this.toast = '', 2000);
          }
        },
        async trigger(path) {
          try {
            const r = await fetch(path, { method: "POST" });
            if (r.ok) {
              const contentType = r.headers.get("content-type");
              if (contentType && contentType.includes("application/json")) {
                const body = await r.json();
                // Replace state directly if it's a full state response
                if (body && (body.players || body.updated_at || Array.isArray(body.games))) {
                  this.state = body;
                  this.interval.min = this.state.min_interval_secs || 0;
                  this.interval.max = this.state.max_interval_secs || 0;

                  // Populate player field on game instances based on player.instance_id
                  const playerMap = {};
                  if (this.state.players) {
                    for (const [name, player] of Object.entries(this.state.players)) {
                      if (player.instance_id) {
                        playerMap[player.instance_id] = name;
                      }
                    }
                  }
                  for (const inst of this.gameInstances) {
                    inst.player = playerMap[inst.id] || "";
                  }
                }
                // Log action results
                if (body.status) {
                  if (body.status === 'partial_failure') {
                    this.log(`${path} partial failure`);
                    const results = body.swap_results || body.results || [];
                    const dl = body.download_results || [];
                    this.log(`swap results: ${JSON.stringify(results)}`);
                    if (dl && dl.length) this.log(`download results: ${JSON.stringify(dl)}`);
                  } else if (body.status === 'ok') {
                    this.log(`${path} OK`);
                  } else {
                    this.log(`${path} status: ${body.status}`);
                  }
                } else {
                  this.log(`${path} response: ${JSON.stringify(body)}`);
                }
              } else {
                this.log(`${path} OK`);
              }
              this.toast = "Action successful";
            } else {
              this.log(`${path} FAIL`);
              this.toast = "Action failed";
            }
            setTimeout(() => (this.toast = ""), 2000);
          } catch (e) {
            this.log("err " + e.message);
          }
        },
        async refreshFilesList() {
          try {
            const r = await fetch('/files/list.json');
            const raw = await r.json();
            // normalize to array of filename strings (server returns {name,size})
            this.files = (raw || []).map(f => {
              if (!f) return '';
              if (typeof f === 'string') return f;
              return f.name || f.Name || '';
            }).filter(Boolean);
          } catch (e) {
            this.log('files list error: ' + e.message);
          }
        },
        // availableFiles(allowUsedInPrimaryOnly=false)
        // returns filenames from this.files that are not already used as a primary file
        // or extra file in the catalog. If allowUsedInPrimaryOnly is true, then
        // the primary file may be included but extras will exclude any files used
        // as a primary elsewhere.
        availableFiles(allowExtras) {
          // Build a set of files used as primary or extras anywhere in the catalog
          const usedAnywhere = new Set();
          for (const e of this.mainGames) {
            if (e.file) usedAnywhere.add(e.file);
            if (e.extra_files) for (const ex of e.extra_files) usedAnywhere.add(ex);
          }
          if (allowExtras) {
            // For extras dropdown: exclude any file used anywhere (primary or extra)
            // and also exclude the currently selected primary so it's not chosen as its own extra.
            return this.files.filter(f => {
              if (!f) return false;
              if (this.newMain && this.newMain.primary && f === this.newMain.primary) return false;
              return !usedAnywhere.has(f);
            });
          }
          // For primary dropdown: exclude files already used anywhere as primary or extra
          return this.files.filter(f => f && !usedAnywhere.has(f));
        },
        addMainEntry() {
          if (!this.newMain.primary) return;
          const entry = { file: this.newMain.primary, extra_files: Array.isArray(this.newMain.extras) ? this.newMain.extras.slice() : [] };
          // ensure not duplicating primary
          if (this.mainGames.some(e => e.file === entry.file)) {
            this.log('file already in catalog');
            return;
          }
          this.mainGames.push(entry);
          this.newMain.primary = '';
          this.newMain.extras = [];
        },
        removeMainEntry(idx) {
          this.mainGames.splice(idx, 1);
        },
        async saveMainGames() {
          try {
            const payload = { main_games: this.mainGames, game_instances: this.gameInstances };
            const res = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (res.ok) {
              this.log('main games saved');
            } else {
              this.log('save main games failed');
            }
          } catch (e) {
            this.log('save main err: ' + e.message);
          }
        },
        addInstance() {
          if (!this.newInstance.id || !this.newInstance.game) {
            this.log("Please enter both Instance ID and Game file.");
            return;
          }
          const newInst = {
            id: this.newInstance.id,
            game: this.newInstance.game,
            file_state: "none",
            player: "" // New instances don't have assigned players initially
          };
          this.gameInstances.push(newInst); // Add to UI list immediately
          this.saveInstances(); // Persist to server
          this.newInstance = { id: "", game: "" }; // Reset the form
        },
        autofillId() {
          if (this.newInstance.game) {
            // Generate ID from game filename: remove extension and sanitize
            const base = this.newInstance.game.replace(/\.[^/.]+$/, ""); // remove extension
            this.newInstance.id = base.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase(); // sanitize
          } else {
            this.newInstance.id = "";
          }
        },
        async saveInstances() {
          try {
            const payload = { main_games: this.mainGames, game_instances: this.gameInstances };
            const res = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (res.ok) {
              this.log('instances saved');
            } else {
              this.log('save instances failed');
            }
          } catch (e) {
            this.log('save instances err: ' + e.message);
          }
        },
        async saveInterval() {
          if (!this.intervalValid) {
            this.log("Invalid interval values");
            return;
          }
          fetch("/api/interval", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              min_interval_secs: this.interval.min,
              max_interval_secs: this.interval.max,
            }),
          }).catch((e) => {
            this.log("interval save err " + e.message);
          });
        },
        async swapPlayer(player, instanceIDOrGame) {
          if (!instanceIDOrGame) return;
          try {
            // If server is in sync mode, send {player, game}, otherwise send {player, instance_id}
            const payload = this.state && this.state.mode === 'sync'
              ? { player, game: instanceIDOrGame }
              : { player, instance_id: instanceIDOrGame };
            const res = await fetch("/api/swap_player", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
          } catch (e) {
            this.log("swap_player err " + e.message);
          }
        },
        async randomSwap(player) {
          if (!player) return;
          try {
            const res = await fetch("/api/random_swap", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ player }),
            });
          } catch (e) {
            this.log("random_swap err " + e.message);
          }
        },
        async swapAll(game) {
          if (!game) return;
          try {
            const res = await fetch("/api/swap_all_to_game", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ game }),
            });
          } catch (e) {
            this.log("swap_all err " + e.message);
          }
        },
        async removePlayer(player) {
          if (!player) return;
          if (!confirm(`Remove player '${player}' from session? This will disconnect them.`)) return;
          try {
            const res = await fetch('/api/remove_player', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player })
            });
            if (res.ok) {
              const body = await res.json().catch(() => null);
              this.log(`remove_player: ${player}`);
            } else {
              this.log(`/api/remove_player failed for ${player}`);
            }
          } catch (e) {
            this.log('remove_player err ' + e.message);
          }
        },
        async messagePlayer(player) {
          if (!player) return;
          this.openMessageComposer('player', player);
        },
        async messageAll() {
          this.openMessageComposer('all');
        },
        startWS() {
          if (this.ws && this.ws.readyState <= 1) {
            // already open or connecting
            return;
          }
          try {
            this.ws = new WebSocket(
              (location.protocol === "https:" ? "wss://" : "ws://") +
              location.host +
              "/ws"
            );
            this.ws.onopen = () => {
              const timestamp = new Date().toLocaleTimeString();
              this.log(`WS Connection: Opened`);
              try {
                // Generate a unique admin name
                const adminName = 'admin_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                const hello = {
                  cmd: "hello_admin",
                  id: String(Date.now()),
                  payload: {
                    name: adminName
                  }
                };
                this.ws.send(JSON.stringify(hello));
                this.log(`Sent admin hello with name: ${adminName}`);
              } catch (e) {
                this.log(`WS hello send error: ${e.message}`);
              }
            };
            this.ws.onclose = () => {
              const timestamp = new Date().toLocaleTimeString();
              this.log(`WS Connection: Closed - Reconnecting in 3s`);
              setTimeout(() => this.startWS(), 3000);
            };
            this.ws.onmessage = (ev) => {
              try {
                const d = JSON.parse(ev.data);
                const timestamp = new Date().toLocaleTimeString();
                this.log(`WS Broadcast: ${d.cmd} ${JSON.stringify(d.payload || {})}`);
                if (d.cmd === "state_update") {
                  this.refreshState();
                }
              } catch (e) {
                const timestamp = new Date().toLocaleTimeString();
                this.log(`WS Broadcast Error: ${ev.data} (${e.message})`);
              }
            };
          } catch (e) {
            const timestamp = new Date().toLocaleTimeString();
            this.log(`WS Connection Error: ${e.message}`);
          }
        },
        // Toggle a game in the sync-mode selection list and persist immediately
        async toggleSyncGame(game, checked) {
          if (!this.selectedGames || !Array.isArray(this.selectedGames)) this.selectedGames = [];
          if (checked) {
            if (!this.selectedGames.includes(game)) this.selectedGames.push(game);
          } else {
            this.selectedGames = this.selectedGames.filter(g => g !== game);
          }
          // Immediately persist via POST /api/games using legacy shape { games: [...] }
          try {
            const res = await fetch('/api/games', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ games: this.selectedGames }),
            });
            if (res.ok) {
              this.log('sync games updated');
            } else {
              this.log('failed to save sync games');
            }
          } catch (e) {
            this.log('toggleSyncGame err: ' + e.message);
          }
        },
        // toggle accordion sections; ensure mutual exclusivity
        toggleSection(name) {
          if (name === 'games') {
            this.showGamesExpanded = !this.showGamesExpanded;
            if (this.showGamesExpanded) {
              this.showSavesExpanded = false;
              this.showPluginsExpanded = false;
            }
          } else if (name === 'saves') {
            this.showSavesExpanded = !this.showSavesExpanded;
            if (this.showSavesExpanded) {
              this.showGamesExpanded = false;
              this.showPluginsExpanded = false;
            }
          } else if (name === 'plugins') {
            this.showPluginsExpanded = !this.showPluginsExpanded;
            if (this.showPluginsExpanded) {
              this.showGamesExpanded = false;
              this.showSavesExpanded = false;
            }
          }
          // small timeout to allow layout changes then refresh scrollable lists if needed
          setTimeout(() => {
            // nothing heavy here; future hooks could recalc virtual lists
          }, 100);
        },
        // Plugin management functions
        async refreshPlugins() {
          try {
            const res = await fetch('/api/plugins');
            if (res.ok) {
              const body = await res.json();
              this.plugins = body.plugins || {};
            }
          } catch (e) {
            this.log('refresh plugins err: ' + e.message);
          }
        },
        async showPluginDetails(name) {
          try {
            const res = await fetch(`/api/plugins/${encodeURIComponent(name)}`);
            if (res.ok) {
              const body = await res.json();
              this.pluginDetails = body || { name };
              // pretty-print meta if available
              this.pluginDetails.metaRaw = JSON.stringify(body.meta || body, null, 2);
            } else {
              this.pluginDetails = { name, description: 'Failed to fetch plugin details' };
              this.pluginDetails.metaRaw = '';
            }
          } catch (e) {
            this.pluginDetails = { name, description: 'Error: ' + e.message };
            this.pluginDetails.metaRaw = '';
          }
          this.pluginDetailsVisible = true;
        },
        async deletePlugin(name) {
          if (!confirm(`Delete plugin '${name}' from server? This cannot be undone.`)) return;
          try {
            const res = await fetch(`/api/plugins/${encodeURIComponent(name)}`, { method: 'DELETE' });
            if (res.ok) {
              this.log(`Deleted plugin ${name}`);
              await this.refreshPlugins();
            } else {
              const msg = await res.text().catch(() => 'delete failed');
              this.log(`Failed to delete plugin ${name}: ${msg}`);
            }
          } catch (e) {
            this.log('delete plugin err: ' + e.message);
          }
        },
        async togglePlugin(name, enable) {
          const action = enable ? 'enable' : 'disable';
          try {
            const res = await fetch(`/api/plugins/${name}/${action}`, { method: 'POST' });
            if (res.ok) {
              this.log(`Plugin ${name} ${action}d`);
              await this.refreshPlugins();
            } else {
              this.log(`Failed to ${action} plugin ${name}`);
            }
          } catch (e) {
            this.log(`Plugin ${action} err: ` + e.message);
          }
        },
        async uploadPlugin(event) {
          const file = event.target.files[0];
          if (!file) return;

          try {
            const formData = new FormData();
            formData.append('plugin', file);

            const res = await fetch('/api/plugins/upload', {
              method: 'POST',
              body: formData
            });

            if (res.ok) {
              const message = await res.text();
              this.log(message);
              await this.refreshPlugins();
            } else {
              const error = await res.text();
              this.log('Plugin upload failed: ' + error);
            }
          } catch (e) {
            this.log('Upload error: ' + e.message);
          } finally {
            // Reset the file input
            event.target.value = '';
          }
        },
        // Message composer functions
        openMessageComposer(target, playerName = null) {
          this.messageTarget = { type: target, player: playerName };
          this.showMessageComposer = true;
        },
        closeMessageComposer() {
          this.showMessageComposer = false;
          // Keep values for next time - don't reset
          this.messageTarget = null;
        },
        resetMessageComposer() {
          this.messageComposer = {
            text: "",
            duration: 3,
            x: 10,
            y: 10,
            fontsize: 12,
            fg: "#FFFFFF",
            bg: "#000000"
          };
        },
        async sendComposedMessage() {
          if (!this.messageComposer.text.trim()) return;

          try {
            const payload = {
              message: this.messageComposer.text,
              duration: this.messageComposer.duration,
              x: this.messageComposer.x,
              y: this.messageComposer.y,
              fontsize: this.messageComposer.fontsize,
              fg: this.messageComposer.fg,
              bg: this.messageComposer.bg
            };

            let url, logMsg;
            if (this.messageTarget.type === 'player') {
              url = '/api/message_player';
              payload.player = this.messageTarget.player;
              logMsg = `message sent to ${this.messageTarget.player}`;
            } else {
              url = '/api/message_all';
              logMsg = 'message sent to all players';
            }

            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (res.ok) {
              this.log(logMsg + ': "' + this.messageComposer.text + '"');
              // Don't close modal - keep it open for more messages
              // Clear just the text field for convenience
              this.messageComposer.text = "";
            } else {
              this.log('Message send failed');
            }
          } catch (e) {
            this.log('Message send error: ' + e.message);
          }
        },
        // Drag and Drop Functions
        onDragStart(event, playerName, type) {
          this.draggedPlayer = playerName;
          this.draggedType = type;
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', playerName);
          event.target.classList.add('opacity-50');
        },
        onDragEnd(event) {
          this.draggedPlayer = null;
          this.draggedType = null;
          event.target.classList.remove('opacity-50');
          // Remove all drag-over highlights
          document.querySelectorAll('.drag-over').forEach(el => {
            el.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');
          });
        },
        onDragOver(event) {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'move';
          event.currentTarget.classList.add('drag-over');
          // Add specific visual feedback based on element type
          if (event.currentTarget.classList.contains('border-dashed')) {
            event.currentTarget.classList.add('bg-blue-900/30', 'border-blue-400');
          } else {
            event.currentTarget.classList.add('bg-blue-900/50', 'border-blue-500', 'scale-105');
          }
        },
        onDragLeave(event) {
          event.currentTarget.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');
        },
        async onDrop(event, targetId, targetType) {
          event.preventDefault();
          event.currentTarget.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');

          if (!this.draggedPlayer) return;

          const playerName = this.draggedPlayer;

          try {
            if (targetType === 'instance') {
              await this.handlePlayerToInstanceDrop(playerName, targetId);
            } else if (targetType === 'unassigned') {
              await this.handlePlayerToUnassignedDrop(playerName);
            }
          } catch (e) {
            this.log('Drop error: ' + e.message);
          }

          this.draggedPlayer = null;
          this.draggedType = null;
        },
        async handlePlayerToInstanceDrop(playerName, instanceId) {
          // Find the target instance
          const targetInstance = this.gameInstances.find(inst => inst.id === instanceId);

          if (!targetInstance) {
            // Instance doesn't exist - check if we need to create one
            const unassignedPlayers = this.unassignedPlayers;
            if (unassignedPlayers.length > 0) {
              // Create a new instance for the first unassigned player
              const firstUnassigned = unassignedPlayers[0];
              this.log(`Creating new instance for unassigned player ${firstUnassigned}`);

              // Generate a new instance ID based on the game file
              const gameFile = this.mainGamesList[0] || 'unknown';
              const base = gameFile.replace(/\.[^/.]+$/, ""); // remove extension
              const newInstanceId = base.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase() + '_' + Date.now();

              // Add the new instance
              const newInstance = {
                id: newInstanceId,
                game: gameFile,
                file_state: "none",
                player: firstUnassigned
              };

              this.gameInstances.push(newInstance);
              await this.saveInstances();

              // Now swap the dragged player to this new instance
              if (firstUnassigned !== playerName) {
                await this.swapPlayer(playerName, newInstanceId);
              }
            }
            return;
          }

          // Find the current instance of the dragged player
          const currentInstance = this.gameInstances.find(inst => inst.player === playerName);

          if (targetInstance.player) {
            // Target instance has a player - swap them
            const targetPlayer = targetInstance.player;

            if (currentInstance) {
              // Both players have instances - swap them
              this.log(`Swapping ${playerName} with ${targetPlayer}`);
              await this.swapPlayer(playerName, instanceId);
              // The swap should handle both directions
            } else {
              // Dragged player is unassigned, target has player - move to empty spot
              this.log(`Moving unassigned ${playerName} to instance ${instanceId}`);
              await this.swapPlayer(playerName, instanceId);
            }
          } else {
            // Target instance is empty - just assign the player
            this.log(`Assigning ${playerName} to empty instance ${instanceId}`);
            await this.swapPlayer(playerName, instanceId);
          }
        },
        async handlePlayerToUnassignedDrop(playerName) {
          // Find if player is currently assigned to an instance
          const currentInstance = this.gameInstances.find(inst => inst.player === playerName);

          if (currentInstance) {
            // Player is assigned - unassign them by swapping to empty instance
            this.log(`Unassigning ${playerName} from instance ${currentInstance.id}`);
            // For unassignment, we need to call swap with an empty instance_id
            // This should be handled by the server when instance_id is empty or null
            await this.swapPlayer(playerName, '');
          } else {
            // Player is already unassigned - do nothing
            this.log(`${playerName} is already unassigned`);
          }
        },
      };
    }
  </script>
</body>

</html>