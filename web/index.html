<!doctype html>
<html lang="en" class="h-full bg-background">

<head>
  <meta charset="utf-8" />
  <title>BizShuffle Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <script>
    // Global sleep helper: await sleep(ms)
    window.sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    tailwind.config = {
      theme: {
        extend: {
          colors: { background: "#0f1724", card: "#071122" },
        },
      },
    };
  </script>
  <style>
    [draggable="true"] {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    [draggable="true"] * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* Prevent number width jitter by using tabular numbers */
    .numeric {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum";
    }

    /* Stable button sizing to avoid layout shift when swapping text/spinners */
    .btn-stable {
      width: 10rem;
      height: 2.25rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
  </style>
  <script defer src="https://unpkg.com/alpinejs@3.12.0/dist/cdn.min.js"></script>
</head>

<body x-data="app()" x-init="init()" class="text-white font-inter h-full flex flex-col">
  <!-- Top swap progress bar: thin indicator that fills to the right until next swap -->
  <div class="fixed top-0 left-0 w-full h-1 z-50 pointer-events-none">
    <div x-show="state.next_swap_at" class="h-full bg-white/10 w-full">
      <!-- Use GPU-accelerated transform scaleX for smooth continuous updates -->
      <div id="swap-progress" class="h-full origin-left" :style="'transform: scaleX(' + (swapProgressPercent / 100) + ')'
          " style="transform-origin:left; will-change:transform; background-color: rgba(52,211,153,1);"
        x-bind:class="(swapProgressPercent >= 95 ? 'bg-amber-400' : 'bg-green-400')"></div>
    </div>
  </div>
  <!-- Main -->
  <main class="mx-auto px-6 py-8 flex-1 grid gap-6 lg:grid-cols-3">
    <!-- Sidebar (Session, Games, Saves) -->
    <!-- changed to flex column so expanded accordion panels can grow to fill available vertical space -->
    <div class="flex flex-col gap-6 h-full">
      <!-- Session -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <div class="flex justify-between items-center">
          <div>
            <p class="text-sm text-gray-400">Session</p>
            <p class="text-lg font-bold inline-block min-w-[6.5rem]"
              :class="state.running ? 'text-green-400' : 'text-red-400'" x-text="state.running ? 'Running' : 'Stopped'">
            </p>
            <p class="text-xs text-gray-500" x-text="'Updated: ' + lastUpdated"></p>
          </div>
          <div class="text-right">
            <p class="text-sm text-gray-400">Next swap</p>
            <p class="text-lg font-bold numeric inline-block min-w-[8ch] text-right" x-text="nextSwapDisplay"></p>
          </div>
        </div>

        <div class="mt-3">
          <label class="block text-sm text-gray-300 mb-1">Mode</label>
          <select x-model="state.mode" @change="setMode(state.mode)" class="px-2 py-1 rounded bg-slate-700">
            <option value="sync">Sync swap (all same game)</option>
            <option value="save">Save swap (per-player saves)</option>
          </select>
        </div>

        <div class="mt-4 flex flex-wrap gap-2">
          <template x-for="btn in sessionButtons" :key="btn.label">
            <button @click="trigger(btn.path)" class="px-1 py-1 rounded font-semibold transition btn-stable"
              :class="getButtonClass(btn)" :title="getButtonTitle(btn)">
              <span class="inline-flex items-center gap-2 justify-center w-full">
                <span x-text="btn.label"></span>
                <!-- small On/Off badge for the Toggle Swaps button -->
                <template x-if="btn.path === '/api/toggle_swaps'">
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="state.swap_enabled ? 'bg-white/90 text-black' : 'bg-slate-800 text-gray-300'"
                    x-text="state.swap_enabled ? 'On' : 'Off'"></span>
                </template>
                <!-- small On/Off badge for the Prevent Same Game button -->
                <template x-if="btn.path === '/api/toggle_prevent_same_game'">
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="state.prevent_same_game_swap ? 'bg-white/90 text-black' : 'bg-slate-800 text-gray-300'"
                    x-text="state.prevent_same_game_swap ? 'On' : 'Off'"></span>
                </template>
                <!-- small On/Off badge for the Countdown button -->
                <template x-if="btn.path === '/api/toggle_countdown'">
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="state.countdown_enabled ? 'bg-white/90 text-black' : 'bg-slate-800 text-gray-300'"
                    x-text="state.countdown_enabled ? 'On' : 'Off'"></span>
                </template>
              </span>
            </button>
          </template>
        </div>

        <!-- Interval -->
        <div class="mt-6">
          <label class="block text-sm text-gray-300 mb-1">Swap interval (secs)</label>
          <p class="text-sm text-gray-400 mb-2 numeric" x-text="intervalDisplay"></p>

          <div class="flex flex-wrap items-center gap-3">
            <input x-model.number="interval.min" type="number" placeholder="min"
              class="w-24 px-2 py-1 rounded bg-transparent border border-white/20 text-white numeric" />
            <input x-model.number="interval.max" type="number" placeholder="max"
              class="w-24 px-2 py-1 rounded bg-transparent border border-white/20 text-white numeric" />
            <button @click="saveInterval()" :disabled="!intervalValid"
              class="px-4 py-1 rounded font-semibold transition"
              :class="intervalValid ? 'bg-slate-700 hover:bg-slate-600' : 'bg-slate-800 text-gray-500 cursor-not-allowed'">
              Save
            </button>
          </div>
          <p class="text-xs text-red-400 mt-2" x-show="intervalError" x-text="intervalError"></p>
        </div>
      </section>
    </div>

    <div class="space-y-6 col-span-2">
      <!-- Players -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <div class="flex justify-between items-center mb-3">
          <div>
            <h2 class="text-sm text-gray-400">Players</h2>
            <p class="text-xs text-gray-500">
              Connected clients & current game
            </p>
          </div>
          <div class="flex gap-2">
            <button @click="messageAll()" class="px-3 py-1 rounded bg-blue-600 hover:bg-blue-500">
              Message All
            </button>
            <button @click="removeAllCompletions()" class="px-3 py-1 rounded bg-red-600 hover:bg-red-500">
              Remove All Completions
            </button>
            <button @click="refreshState()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
              Refresh
            </button>
          </div>
        </div>
        <!-- Add new player form -->
        <div class="mb-3 p-3 bg-slate-800/40 rounded">
          <div class="flex items-center gap-2">
            <input type="text" x-model="newPlayerName" placeholder="Player name"
              class="flex-1 bg-slate-700 rounded px-2 py-1 text-sm text-white" @keyup.enter="addPlayer()" />
            <button @click="addPlayer()" :disabled="!newPlayerName || !newPlayerName.trim()"
              class="px-3 py-1 rounded text-sm font-semibold transition"
              :class="newPlayerName && newPlayerName.trim() ? 'bg-green-600 hover:bg-green-500' : 'bg-slate-800 text-gray-500 cursor-not-allowed'">
              Add Player
            </button>
          </div>
        </div>
        <ul class="space-y-2">
          <template x-for="(p, name) in state.players" :key="name">
            <li
              class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 bg-slate-800/40 p-3 rounded hover:bg-slate-700/40 transition-all"
              draggable="true" @dragstart="onDragStart($event, name, 'player')" @dragend="onDragEnd($event)">
              <!-- Left side: player info -->
              <div class="flex-1 min-w-0">
                <div class="flex items-baseline gap-3">
                  <strong class="truncate max-w-[10rem] sm:max-w-[14rem] select-none flex items-center gap-1"
                    x-text="name">
                    <svg class="w-3 h-3 text-gray-400 opacity-50" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                    </svg>
                  </strong>
                  <div class="text-xs text-gray-400 truncate" x-text="p.game || '-'"></div>
                  <div class="text-xs text-gray-400 truncate" x-text="p.instance_id || '-'"></div>
                </div>

                <div class="mt-1 flex flex-wrap items-center gap-2">
                  <span class="text-xs px-2 py-0.5 rounded-full"
                    :class="p.connected ? (p.bizhawk_ready ? 'bg-green-500/20 text-green-400' : 'bg-orange-500/20 text-orange-400') : 'bg-red-500/20 text-red-400'"
                    x-text="p.connected ? (p.bizhawk_ready ? 'Connected (BizHawk Ready)' : 'Connected (BizHawk Not Ready)') : 'Offline'"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full"
                    :class="p.has_files ? 'bg-green-600/10 text-green-300' : 'bg-yellow-600/10 text-yellow-300'"
                    x-text="p.has_files ? 'Has files' : 'Missing files'"></span>
                  <span class="text-xs text-gray-400"
                    x-text="p.ping_ms ? ('ping: ' + p.ping_ms + 'ms') : 'No ping'"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full bg-orange-600/20 text-orange-300"
                    x-show="getPlayerCompletionCount(p) > 0" x-text="getPlayerCompletionCount(p) + ' completed'"></span>
                  <button @click="p.showCompleted = !p.showCompleted"
                    class="text-xs px-2 py-0.5 rounded bg-slate-700 hover:bg-slate-600">
                    <span x-text="p.showCompleted ? 'Hide Completed' : 'Completed'"></span>
                  </button>
                </div>
                <!-- Completed Games/Instances Section -->
                <div x-show="p.showCompleted" class="mt-2 p-2 bg-slate-900/40 rounded text-xs">
                  <div class="mb-2">
                    <div class="text-gray-300 mb-1">Completed Games (Sync Mode):</div>
                    <div class="flex flex-wrap gap-1 mb-2">
                      <template x-for="cg in (p.completed_games || [])" :key="cg">
                        <span class="px-2 py-0.5 bg-red-600/20 text-red-300 rounded flex items-center gap-1">
                          <span x-text="cg"></span>
                          <button @click="removeCompletedGame(name, cg)"
                            class="text-red-400 hover:text-red-200">×</button>
                        </span>
                      </template>
                      <template x-if="!p.completed_games || p.completed_games.length === 0">
                        <span class="text-gray-500">None</span>
                      </template>
                    </div>
                    <div class="flex gap-1">
                      <select x-model="p.newCompletedGame" class="bg-slate-700 rounded text-xs flex-1">
                        <option value="">-- select game --</option>
                        <template x-for="g in state.games" :key="g">
                          <option :value="g" x-text="g"></option>
                        </template>
                      </select>
                      <button @click="addCompletedGame(name, p.newCompletedGame); p.newCompletedGame = ''"
                        :disabled="!p.newCompletedGame"
                        class="px-2 py-1 rounded text-xs bg-green-600 hover:bg-green-500 disabled:bg-slate-800 disabled:text-gray-500">
                        Add
                      </button>
                    </div>
                  </div>
                  <div>
                    <div class="text-gray-300 mb-1">Completed Instances (Save Mode):</div>
                    <div class="flex flex-wrap gap-1 mb-2">
                      <template x-for="ci in (p.completed_instances || [])" :key="ci">
                        <span class="px-2 py-0.5 bg-red-600/20 text-red-300 rounded flex items-center gap-1">
                          <span x-text="ci"></span>
                          <button @click="removeCompletedInstance(name, ci)"
                            class="text-red-400 hover:text-red-200">×</button>
                        </span>
                      </template>
                      <template x-if="!p.completed_instances || p.completed_instances.length === 0">
                        <span class="text-gray-500">None</span>
                      </template>
                    </div>
                    <div class="flex gap-1">
                      <select x-model="p.newCompletedInstance" class="bg-slate-700 rounded text-xs flex-1">
                        <option value="">-- select instance --</option>
                        <template x-for="inst in gameInstances" :key="inst.id">
                          <option :value="inst.id" x-text="inst.id + ' — ' + inst.game"></option>
                        </template>
                      </select>
                      <button @click="addCompletedInstance(name, p.newCompletedInstance); p.newCompletedInstance = ''"
                        :disabled="!p.newCompletedInstance"
                        class="px-2 py-1 rounded text-xs bg-green-600 hover:bg-green-500 disabled:bg-slate-800 disabled:text-gray-500">
                        Add
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Right side: controls -->
              <div class="flex items-center gap-2 min-w-0">
                <!-- If in sync mode, let user pick a game; otherwise pick an instance -->
                <template x-if="state.mode === 'sync'">
                  <select x-model="p.selectedGame" class="bg-slate-700 rounded text-sm max-w-[12rem] truncate">
                    <option value="">-- select game --</option>
                    <template x-for="g in state.games" :key="g">
                      <option :value="g" x-text="g"></option>
                    </template>
                  </select>
                </template>
                <template x-if="state.mode !== 'sync'">
                  <select x-model="p.selectedGame" class="bg-slate-700 rounded text-sm max-w-[12rem] truncate">
                    <option value="">-- select instance --</option>
                    <template x-for="inst in gameInstances" :key="inst.id">
                      <option :value="inst.id" x-text="inst.id + ' — ' + inst.game"></option>
                    </template>
                  </select>
                </template>

                <button @click="swapPlayer(name, p.selectedGame)"
                  class="px-2 py-1 rounded text-xs font-semibold transition whitespace-nowrap"
                  :class="p.selectedGame ? 'bg-slate-700 hover:bg-slate-600' : 'bg-slate-800 text-gray-500 cursor-not-allowed'">
                  Swap
                </button>
                <button @click="randomSwap(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-emerald-500 hover:bg-emerald-400 text-black">
                  Random
                </button>
                <button @click="messagePlayer(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-blue-600 hover:bg-blue-500">
                  Message
                </button>
                <button @click="toggleFullscreen(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-purple-600 hover:bg-purple-500">
                  Fullscreen
                </button>
                <button @click="checkPlayerConfig(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-blue-600 hover:bg-blue-500">
                  Check Config
                </button>
                <button @click="removePlayer(name)"
                  class="px-2 py-1 rounded text-xs font-semibold transition bg-red-600 hover:bg-red-500">
                  Remove
                </button>
              </div>
            </li>
          </template>
        </ul>
      </section>

      <!-- Games -->
      <template x-if="state.mode === 'sync'">
        <section
          :class="showGamesExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
          class="transition-all">
          <div class="flex justify-between items-center">
            <h2 class="text-sm text-gray-400">Games</h2>
            <div class="flex gap-2">
              <button @click="toggleSection('games')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
                <span x-text="showGamesExpanded ? 'Collapse' : 'Expand'"></span>
              </button>
              <button @click="openRomsFolder()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm">
                Open Roms Folder
              </button>
              <button @click="showCatalog = true" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
                Catalog
              </button>
              <button @click="setupGameMode()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
                Auto Setup
              </button>
            </div>
          </div>
          <!-- Saved instances list -->
          <div
            :class="showGamesExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-60 overflow-auto'">
            <!-- If sync mode, show list of available games with a Swap All button -->
            <template x-for="(g, idx) in mainGamesList" :key="g">
              <div class="flex justify-between items-center bg-slate-800/40 p-2 rounded">
                <div class="flex items-center gap-3">
                  <input type="checkbox" :id="'sync-game-'+idx" :value="g"
                    x-bind:checked="selectedGames && selectedGames.includes(g)"
                    @change="toggleSyncGame(g, $event.target.checked)" class="w-4 h-4" />
                  <label :for="'sync-game-'+idx" class="text-sm font-mono text-gray-200 truncate" x-text="g"></label>
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold bg-blue-500 text-white"
                    x-show="countPlayersOnGame(g) > 0"
                    x-text="countPlayersOnGame(g) + ' player' + (countPlayersOnGame(g) > 1 ? 's' : '')"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold bg-orange-600/20 text-orange-300"
                    x-show="countPlayersCompletedGame(g) > 0"
                    x-text="countPlayersCompletedGame(g) + ' completed'"></span>
                </div>
                <div class="flex gap-2">
                  <button @click="swapAll(g)"
                    class="text-xs px-2 py-1 rounded bg-emerald-500 hover:bg-emerald-400 text-black">Swap All</button>
                  <button @click="markGameCompletedForAll(g)"
                    class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Mark Completed (All)</button>
                </div>
              </div>
            </template>
          </div>
        </section>
      </template>
      <template x-if="state.mode === 'save'">
        <section
          :class="showGamesExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
          class="transition-all">
          <div class="flex justify-between items-center">
            <h2 class="text-sm text-gray-400">Games</h2>
            <div class="flex gap-2">
              <button @click="toggleSection('games')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
                <span x-text="showGamesExpanded ? 'Collapse' : 'Expand'"></span>
              </button>
              <button @click="openRomsFolder()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm">
                Open Roms Folder
              </button>
              <button @click="showCatalog = true" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
                Catalog
              </button>
              <button @click="setupGameMode()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">
                Auto Setup
              </button>
            </div>
          </div>
          <!-- Saved instances list -->
          <div
            :class="showGamesExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-60 overflow-auto'">

            <template x-for="(inst, idx) in gameInstances" :key="inst.id">
              <div
                class="flex justify-between items-center bg-slate-800/40 p-2 rounded transition-all hover:bg-slate-700/40 border-2 border-transparent"
                @dragover.prevent="onDragOver($event)" @dragleave="onDragLeave($event)"
                @drop="onDrop($event, inst.id, 'instance')">
                <div class="flex flex-col">
                  <span class="text-sm font-mono text-gray-200" x-text="inst.id"></span>
                  <span class="text-sm text-gray-400" x-text="inst.game || '(no game)'"></span>
                  <div class="flex items-center gap-2">
                    <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                      :class="inst.file_state === 'ready' ? 'bg-green-500/20 text-green-400' : inst.file_state === 'pending' ? 'bg-yellow-500/20 text-yellow-400' : 'bg-gray-500/20 text-gray-400'"
                      x-text="(inst.file_state || 'none') + (inst.pending_player ? ': ' + inst.pending_player : '')">
                    </span>
                    <span class="text-xs text-gray-500" x-text="inst.player ? 'assigned:' : 'unassigned'"></span>
                    <span class="text-xs px-2 py-0.5 rounded-full font-semibold bg-orange-600/20 text-orange-300"
                      x-show="countPlayersCompletedInstance(inst.id) > 0"
                      x-text="countPlayersCompletedInstance(inst.id) + ' completed'"></span>
                  </div>
                  <template x-if="inst.player">
                    <span
                      class="px-2 py-1 bg-blue-600/20 text-blue-300 rounded text-xs cursor-move select-none flex items-center gap-1 hover:bg-blue-600/30 transition-colors"
                      draggable="true" @dragstart="onDragStart($event, inst.player, 'player')"
                      @dragend="onDragEnd($event)">
                      <svg class="w-3 h-3 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                        <path
                          d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                      </svg>
                      <span x-text="inst.player"></span>
                    </span>
                  </template>
                </div>
                <div class="flex gap-2">
                  <button @click="markInstanceCompletedForAll(inst.id)"
                    class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Mark Completed (All)</button>
                  <button @click="() => { gameInstances.splice(idx,1); saveInstances(); }"
                    class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Remove</button>
                </div>
              </div>
            </template>
          </div>

          <!-- Unassigned Players Drop Zone -->
          <div
            class="mt-4 p-4 border-2 border-dashed border-slate-600 rounded-lg bg-slate-800/20 transition-all hover:bg-slate-700/30 hover:border-slate-500"
            @dragover.prevent="onDragOver($event)" @dragleave="onDragLeave($event)"
            @drop="onDrop($event, null, 'unassigned')">
            <div class="text-center">
              <div class="text-sm text-gray-400 mb-2">Unassigned Players</div>
              <div class="text-xs text-gray-500">Drop players here to unassign them</div>
              <div class="mt-2 flex flex-wrap gap-2 justify-center" x-show="unassignedPlayers.length > 0">
                <template x-for="player in unassignedPlayers" :key="player">
                  <span
                    class="px-2 py-1 bg-slate-700 rounded text-xs cursor-move select-none hover:bg-slate-600 transition-colors flex items-center gap-1"
                    draggable="true" @dragstart="onDragStart($event, player, 'player')" @dragend="onDragEnd($event)">
                    <svg class="w-3 h-3 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                      <path
                        d="M3 4h14a1 1 0 010 2H3a1 1 0 010-2zM3 8h14a1 1 0 010 2H3a1 1 0 010-2zM3 12h14a1 1 0 010 2H3a1 1 0 010-2z" />
                    </svg>
                    <span x-text="player"></span>
                  </span>
                </template>
              </div>
              <div class="text-xs text-gray-500 mt-2" x-show="unassignedPlayers.length === 0">No unassigned players
              </div>
            </div>
          </div>

          <div class="mt-4 p-3 bg-slate-800/40 rounded">
            <h3 class="text-sm text-gray-300 mb-2">Add New Instance</h3>
            <div class="flex items-center gap-2">
              <input class="bg-slate-700 rounded px-2 py-1 text-sm w-48" type="text" placeholder="Instance ID"
                x-model="newInstance.id" />
              <select x-model="newInstance.game" @change="autofillId()"
                class="bg-slate-700 rounded px-2 py-1 text-sm max-w-[12rem]">
                <option value="">-- select file --</option>
                <template x-for="f in mainGamesList" :key="f">
                  <option :value="f" x-text="f"></option>
                </template>
              </select>
              <button @click="addInstance()" class="px-3 py-1 rounded bg-green-600 hover:bg-green-500 text-sm">
                Add
              </button>
            </div>
          </div>
        </section>
      </template>

      <!-- Plugins -->
      <section
        :class="showPluginsExpanded ? 'flex-1 flex flex-col bg-card border border-white/10 p-4 rounded-lg shadow' : 'bg-card border border-white/10 p-4 rounded-lg shadow'"
        class="transition-all">
        <div class="flex justify-between items-center">
          <h2 class="text-sm text-gray-400">Plugins</h2>
          <div class="flex gap-2">
            <button @click="toggleSection('plugins')" class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">
              <span x-text="showPluginsExpanded ? 'Collapse' : 'Expand'"></span>
            </button>
            <button @click="openPluginsFolder()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm">
              Open Plugins Folder
            </button>
            <button @click="refreshPlugins()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm">
              Refresh
            </button>
          </div>
        </div>

        <div
          :class="showPluginsExpanded ? 'mt-2 flex-1 overflow-auto space-y-2' : 'mt-2 space-y-2 max-h-40 overflow-auto'">
          <template x-for="(plugin, name) in plugins" :key="name">
            <div class="flex justify-between items-center bg-slate-800/40 p-2 rounded">
              <div class="flex-1">
                <div class="flex items-center gap-2">
                  <span class="text-sm font-medium" x-text="plugin.name"></span>
                  <span class="text-xs px-2 py-0.5 rounded-full font-semibold"
                    :class="plugin.status === 'enabled' ? 'bg-green-400 text-black' : plugin.status === 'error' ? 'bg-red-400 text-black' : 'bg-slate-600 text-gray-300'"
                    x-text="plugin.status"></span>
                </div>
                <div class="text-xs text-gray-400" x-text="plugin.description || 'No description'"></div>
                <div class="text-xs text-gray-500"
                  x-text="'v' + (plugin.version || '1.0.0') + ' by ' + (plugin.author || 'Unknown')"></div>
              </div>
              <div class="flex gap-1">
                <button @click="togglePlugin(name, plugin.status !== 'enabled')"
                  class="text-xs px-2 py-1 rounded transition-colors"
                  :class="plugin.status === 'enabled' ? 'bg-orange-500 hover:bg-orange-400 text-black' : 'bg-green-500 hover:bg-green-400 text-black'"
                  x-text="plugin.status === 'enabled' ? 'Disable' : 'Enable'">
                </button>
                <button @click="reloadPlugin(name)"
                  class="text-xs px-2 py-1 rounded bg-blue-600 hover:bg-blue-500">Reload</button>
                <button @click="showPluginDetails(name)"
                  class="text-xs px-2 py-1 rounded bg-slate-700 hover:bg-slate-600">Edit</button>
                <button @click="deletePlugin(name)"
                  class="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-500">Delete</button>
              </div>
            </div>
          </template>

          <div x-show="Object.keys(plugins).length === 0" class="text-sm text-gray-500 text-center py-4">
            No plugins found. Add plugins to the plugins folder to get started.
          </div>
        </div>
      </section>

      <!-- Plugin Edit Settings Modal -->
      <div x-show="pluginDetailsVisible" x-transition
        class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
        <div class="bg-card rounded-lg w-11/12 max-w-2xl p-4 max-h-[90vh] overflow-y-auto">
          <div class="flex justify-between items-center mb-3">
            <h3 class="text-lg font-bold">Edit Settings: <span x-text="pluginDetails.name"></span></h3>
            <div class="flex gap-2">
              <button @click="pluginDetailsVisible = false"
                class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Close</button>
            </div>
          </div>

          <!-- Read-only metadata section -->
          <div class="mb-4 p-3 bg-slate-800/40 rounded">
            <div class="text-sm text-gray-400 mb-1" x-text="pluginDetails.description || 'No description'"></div>
            <div class="grid grid-cols-2 gap-4 text-sm">
              <div>
                <span class="text-gray-500">Version:</span>
                <span class="ml-2" x-text="pluginDetails.version || '1.0.0'"></span>
              </div>
              <div>
                <span class="text-gray-500">Author:</span>
                <span class="ml-2" x-text="pluginDetails.author || 'Unknown'"></span>
              </div>
            </div>
          </div>

          <!-- Settings section -->
          <div class="mb-4">
            <div class="text-sm font-semibold mb-2">Settings</div>

            <!-- Status field (always shown) -->
            <div class="mb-3">
              <label class="block text-xs text-gray-400 mb-1">Status *</label>
              <select x-model="pluginSettings.status" class="w-full px-2 py-1 rounded bg-slate-700 text-white">
                <option value="enabled">Enabled</option>
                <option value="disabled">Disabled</option>
              </select>
            </div>

            <!-- Dynamic settings fields -->
            <template x-for="(value, key) in pluginSettings" :key="key">
              <div class="mb-3" x-show="key !== 'status'">
                <label class="block text-xs text-gray-400 mb-1" x-text="key"></label>
                <!-- Multiselect checkboxes for settings with metadata type=multiselect -->
                <template
                  x-if="pluginDetails.settings_meta && pluginDetails.settings_meta[key] && pluginDetails.settings_meta[key].type === 'multiselect'">
                  <div class="space-y-2">
                    <template x-for="option in pluginDetails.settings_meta[key].options" :key="option">
                      <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" :value="option"
                          @change="updateMultiselectSetting(key, option, $event.target.checked)"
                          :checked="isMultiselectOptionSelected(key, option)"
                          class="w-4 h-4 rounded bg-slate-700 border-slate-600 text-blue-600 focus:ring-blue-500" />
                        <span class="text-sm text-gray-300" x-text="option"></span>
                      </label>
                    </template>
                  </div>
                </template>
                <!-- Dropdown for settings with metadata type=dropdown -->
                <template
                  x-if="pluginDetails.settings_meta && pluginDetails.settings_meta[key] && pluginDetails.settings_meta[key].type === 'dropdown'">
                  <select x-model="pluginSettings[key]" class="w-full px-2 py-1 rounded bg-slate-700 text-white">
                    <template x-for="option in pluginDetails.settings_meta[key].options" :key="option">
                      <option :value="option" x-text="option"></option>
                    </template>
                  </select>
                </template>
                <!-- Text input for settings without dropdown/multiselect metadata -->
                <template
                  x-if="!pluginDetails.settings_meta || !pluginDetails.settings_meta[key] || (pluginDetails.settings_meta[key].type !== 'dropdown' && pluginDetails.settings_meta[key].type !== 'multiselect')">
                  <input type="text" x-model="pluginSettings[key]"
                    class="w-full px-2 py-1 rounded bg-slate-700 text-white" :placeholder="'Enter value for ' + key" />
                </template>
              </div>
            </template>

            <!-- Add new setting -->
            <div class="mt-4 p-2 bg-slate-800/40 rounded">
              <div class="text-xs text-gray-400 mb-2">Add New Setting</div>
              <div class="flex gap-2">
                <input type="text" x-model="newSettingKey" placeholder="Setting key"
                  class="flex-1 px-2 py-1 rounded bg-slate-700 text-white text-sm" />
                <input type="text" x-model="newSettingValue" placeholder="Setting value"
                  class="flex-1 px-2 py-1 rounded bg-slate-700 text-white text-sm" />
                <button @click="addSetting()"
                  class="px-3 py-1 rounded bg-green-600 hover:bg-green-500 text-sm">Add</button>
              </div>
            </div>
          </div>

          <!-- Action buttons -->
          <div class="flex justify-end gap-2">
            <button @click="pluginDetailsVisible = false"
              class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600">Cancel</button>
            <button @click="savePluginSettings()" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500">Save
              Settings</button>
          </div>
        </div>
      </div>

      <!-- Logs -->
      <section class="bg-card border border-white/10 p-4 rounded-lg shadow">
        <h2 class="text-sm text-gray-400">Logs</h2>
        <div class="mt-2 bg-[#02101a] p-3 rounded h-96 overflow-auto text-sm space-y-1">
          <template x-for="log in logs" :key="log.id">
            <div>
              <span class="text-gray-500" x-text="log.time"></span>
              <span class="ml-2" x-text="log.message"></span>
            </div>
          </template>
        </div>
      </section>
    </div>
  </main>

  <!-- Toast -->
  <div x-show="toast" x-transition class="fixed bottom-4 right-4 bg-slate-800 text-white px-4 py-2 rounded shadow"
    x-text="toast"></div>

  <!-- Catalog Modal -->
  <div x-show="showCatalog" x-transition class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-card rounded-lg w-11/12 max-w-3xl p-4">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-bold">Main Games (Catalog)</h3>
        <div class="flex gap-2">
          <button @click="showCatalog = false" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Close</button>
        </div>
      </div>
      <p class="text-xs text-gray-500 mb-2">Catalog of game files and any extra files clients should also download.</p>
      <div class="space-y-2 max-h-72 overflow-auto mb-3">
        <template x-for="(g, idx) in mainGames" :key="idx">
          <div class="bg-slate-800/40 p-2 rounded flex items-start justify-between gap-2">
            <div class="flex-1">
              <div class="text-sm font-medium" x-text="g.file"></div>
              <div class="text-xs text-gray-400"
                x-text="g.extra_files && g.extra_files.length ? ('extra: ' + g.extra_files.join(', ')) : 'no extra files'">
              </div>
            </div>
            <div class="flex gap-2">
              <button @click="removeMainEntry(idx)"
                class="px-2 py-1 rounded bg-red-600 hover:bg-red-500 text-xs">Remove</button>
            </div>
          </div>
        </template>
      </div>

      <div class="border-t border-white/5 pt-3">
        <div class="flex items-center gap-2">
          <div class="flex-1">
            <label class="block text-xs text-gray-400 mb-1">Primary file</label>
            <select x-model="newMain.primary" class="w-full bg-slate-700 rounded px-2 py-1 text-sm">
              <option value="">-- select file --</option>
              <template x-for="f in availableFiles()" :key="f">
                <option :value="f" x-text="f"></option>
              </template>
            </select>
          </div>
          <div class="w-36">
            <label class="block text-xs text-gray-400 mb-1">Extras</label>
            <select x-model="newMain.extras" multiple class="w-full bg-slate-700 rounded px-2 py-1 text-sm">
              <template x-for="f in availableFiles(true)" :key="f">
                <option :value="f" x-text="f"></option>
              </template>
            </select>
          </div>
        </div>
        <div class="mt-2 flex gap-2">
          <button @click="addMainEntry()" :disabled="!newMain.primary"
            class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Add</button>
          <button @click="saveMainGames(); showCatalog = false"
            class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Save Catalog</button>
          <button @click="refreshFilesList()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">Refresh
            Files</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Message Composer Modal -->
  <div x-show="showMessageComposer" x-transition
    class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-card rounded-lg w-11/12 max-w-md p-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold">Compose Message</h3>
        <button @click="closeMessageComposer()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">×</button>
      </div>

      <div class="space-y-4">
        <div>
          <label class="block text-sm text-gray-400 mb-1">Message Text</label>
          <textarea x-model="messageComposer.text" class="w-full bg-slate-700 rounded px-2 py-1 text-white resize-none"
            rows="3" placeholder="Enter your message..."></textarea>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Duration (seconds)</label>
            <input x-model.number="messageComposer.duration" type="number" min="1" max="60"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Font Size</label>
            <input x-model.number="messageComposer.fontsize" type="number" min="8" max="48"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">X Position</label>
            <input x-model.number="messageComposer.x" type="number" min="0" max="800"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Y Position</label>
            <input x-model.number="messageComposer.y" type="number" min="0" max="600"
              class="w-full bg-slate-700 rounded px-2 py-1 text-white" />
          </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Text Color</label>
            <input x-model="messageComposer.fg" type="color" class="w-full bg-slate-700 rounded px-2 py-1 h-9" />
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Background Color</label>
            <input x-model="messageComposer.bg" type="color" class="w-full bg-slate-700 rounded px-2 py-1 h-9" />
          </div>
        </div>
      </div>

      <div class="mt-6 flex gap-2 justify-end">
        <button @click="resetMessageComposer()" class="px-4 py-2 rounded bg-gray-600 hover:bg-gray-500">
          Reset
        </button>
        <button @click="closeMessageComposer()" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600">
          Cancel
        </button>
        <button @click="sendComposedMessage()" :disabled="!messageComposer.text.trim()"
          class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 disabled:bg-slate-800 disabled:text-gray-500">
          Send Message
        </button>
      </div>
    </div>
  </div>

  <!-- Config Management Modal -->
  <div x-show="showConfigModal" x-transition
    class="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div class="bg-card rounded-lg w-11/12 max-w-4xl p-4 max-h-[90vh] overflow-y-auto">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold">BizHawk Config: <span x-text="configPlayer"></span></h3>
        <button @click="closeConfigModal()" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600">×</button>
      </div>

      <div x-show="!getPlayerConfigValues()" class="text-center py-8">
        <div class="text-gray-400">Loading config...</div>
      </div>

      <div x-show="getPlayerConfigValues()" class="space-y-4">
        <div class="text-sm text-gray-400 mb-4">
          Only the predefined config keys are shown below. You can edit their values and save to apply changes to the player's BizHawk configuration.
        </div>

        <div class="space-y-3">
          <template x-for="key in configKeys" :key="key">
            <div class="border border-white/10 rounded p-3">
              <label class="block text-sm font-medium text-gray-300 mb-2" x-text="key"></label>
              <textarea x-model="configValues[key]"
                class="w-full bg-slate-700 rounded px-2 py-1 text-white font-mono text-sm resize-vertical"
                :placeholder="'Enter value for ' + key"
                rows="2"></textarea>
            </div>
          </template>
        </div>

        <div x-show="configKeys.length === 0" class="text-center py-4 text-gray-500">
          No config keys defined. Set config keys in server state first.
        </div>

        <div class="mt-6 flex gap-2 justify-end">
          <button @click="closeConfigModal()" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600">
            Cancel
          </button>
              <button @click="savePlayerConfig()"
              :disabled="!getPlayerConfigValues() || configKeys.length === 0"
              class="px-4 py-2 rounded bg-orange-600 hover:bg-orange-500 disabled:bg-slate-800 disabled:text-gray-500">
              Save Config (Restart BizHawk Manually)
            </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    function app() {
      return {
        // accordion state: only one of games or saves can be expanded at once
        showGamesExpanded: false,
        showSavesExpanded: false,
        showPluginsExpanded: false,
        loaded: false,
        state: { running: false, games: [], players: {} },
        // UI-managed list of game instances for CRUD
        gameInstances: [],
        newInstance: { id: "", game: "" },
        newPlayerName: "",
        showCatalog: false,
        // main catalog and available files under /files
        mainGames: [],
        files: [],
        plugins: {},
        // Plugin edit settings modal state
        pluginDetailsVisible: false,
        pluginDetails: {},
        pluginSettings: {},
        newSettingKey: "",
        newSettingValue: "",
        newMain: { primary: "", extras: [] },
        saves: {},
        logs: [],
        interval: { min: null, max: null },
        toast: "",
        selectedGames: [],
        ws: null, // store websocket instance
        // Message composer modal state
        showMessageComposer: false,
        messageComposer: {
          text: "",
          duration: 3,
          x: 10,
          y: 10,
          fontsize: 12,
          fg: "#FFFFFF",
          bg: "#000000"
        },
        messageTarget: null, // 'player' or 'all', and player name if player
        // Config management modal state
        showConfigModal: false,
        configPlayer: "",
        configData: null,
        configValues: {},
        configKeys: [],
        // Drag and drop state
        draggedPlayer: null,
        draggedType: null,
        sessionButtons: [
          { label: "Start", path: "/api/start", class: "bg-green-500 text-black" },
          { label: "Pause", path: "/api/pause", class: "bg-slate-700" },
          { label: "Do Swap", path: "/api/do_swap", class: "bg-slate-700" },
          { label: "Auto Swaps", path: "/api/toggle_swaps", class: "bg-slate-700" },
          { label: "Better Random", path: "/api/toggle_prevent_same_game", class: "bg-slate-700" },
          { label: "Countdown", path: "/api/toggle_countdown", class: "bg-slate-700" },
          { label: "Clear Saves", path: "/api/clear_saves", class: "bg-orange-500 text-black" },
        ],
        get lastUpdated() {
          return this.state.updated_at
            ? new Date(this.state.updated_at).toLocaleString()
            : "--";
        },
        get intervalDisplay() {
          return this.state.min_interval_secs && this.state.max_interval_secs
            ? `${this.state.min_interval_secs} - ${this.state.max_interval_secs}`
            : "--";
        },
        // nowMs is kept up-to-date at display refresh rate for smooth animations
        nowMs: Date.now(),
        // legacy second-resolution 'now' for other logic still expecting seconds
        get now() { return Math.floor(this.nowMs / 1000); },
        // percent 0-100 of progress until next swap (0 = just swapped, 100 = swap due)
        get swapProgressPercent() {
          if (!this.state || !this.state.next_swap_at) return 0;
          // Use milliseconds for smoother progress
          const nextMs = this.state.next_swap_at * 1000;
          // Determine interval length in ms. Use max_interval if available else min or default 1s
          const intervalSecs = this.state.max_interval_secs || this.state.min_interval_secs || 1;
          const intervalMs = intervalSecs * 1000;
          const remainingMs = nextMs - this.nowMs;
          if (remainingMs <= 0) return 100;
          const elapsedMs = intervalMs - remainingMs;
          const pct = Math.max(0, Math.min(100, (elapsedMs / intervalMs) * 100));
          return pct;
        },
        get nextSwapDisplay() {
          if (!this.state.next_swap_at) return "--";
          const diff = this.state.next_swap_at - this.now; // seconds until swap
          if (diff <= 0) return "Due";
          // Format as H:MM:SS or M:SS depending on length
          const hrs = Math.floor(diff / 3600);
          const mins = Math.floor((diff % 3600) / 60);
          const secs = diff % 60;
          const pad = (n) => (n < 10 ? '0' + n : '' + n);
          if (hrs > 0) return `${hrs}:${pad(mins)}:${pad(secs)}`;
          return `${mins}:${pad(secs)}`;
        },
        get intervalValid() {
          return (
            this.interval.min > 0 &&
            this.interval.max > 0 &&
            this.interval.min <= this.interval.max
          );
        },
        // unified games list used for displaying file options in the UI.
        get mainGamesList() {
          if (this.mainGames && this.mainGames.length) return this.mainGames.map(e => e.file).filter(Boolean);
          return [];
        },
        get intervalError() {
          if (!this.interval.min || !this.interval.max)
            return "Both values required";
          if (this.interval.min <= 0 || this.interval.max <= 0)
            return "Values must be positive";
          if (this.interval.min > this.interval.max)
            return "Min cannot be greater than Max";
          return "";
        },
        // Computed property for unassigned players
        get unassignedPlayers() {
          const assignedPlayers = new Set();
          for (const inst of this.gameInstances) {
            if (inst.player) assignedPlayers.add(inst.player);
          }
          return Object.keys(this.state.players || {}).filter(player => !assignedPlayers.has(player));
        },
        countPlayersOnGame(game) {
          return Object.values(this.state.players || {}).filter(p => p.game === game).length;
        },
        getPlayerCompletionCount(player) {
          if (!player) return 0;
          const gamesCount = (player.completed_games || []).length;
          const instancesCount = (player.completed_instances || []).length;
          return gamesCount + instancesCount;
        },
        countPlayersCompletedGame(game) {
          if (!game || !this.state.players) return 0;
          return Object.values(this.state.players).filter(p => {
            return (p.completed_games || []).includes(game);
          }).length;
        },
        countPlayersCompletedInstance(instanceId) {
          if (!instanceId || !this.state.players) return 0;
          return Object.values(this.state.players).filter(p => {
            return (p.completed_instances || []).includes(instanceId);
          }).length;
        },
        getButtonClass(btn) {
          if (btn.path === '/api/toggle_swaps') {
            return this.state.swap_enabled ? 'bg-emerald-400 text-black shadow-lg' : 'bg-slate-700';
          } else if (btn.path === '/api/toggle_prevent_same_game') {
            return this.state.prevent_same_game_swap ? 'bg-blue-500 text-white shadow-lg' : 'bg-slate-700';
          } else {
            return btn.class;
          }
        },
        getButtonTitle(btn) {
          if (btn.path === '/api/toggle_swaps') {
            return this.state.swap_enabled ? 'Swaps enabled' : 'Swaps disabled';
          } else if (btn.path === '/api/toggle_prevent_same_game') {
            return this.state.prevent_same_game_swap ? 'Better Random: ON' : 'Better Random: OFF';
          } else {
            return btn.label;
          }
        },
        getPlayerConfigValues() {
          if (!this.configPlayer || !this.state.players) return null;
          const player = this.state.players[this.configPlayer];
          return player ? player.config_values : null;
        },
        // Watch for config data changes and populate form values
        updateConfigFormValues() {
          const configData = this.getPlayerConfigValues();
          if (configData && this.configKeys.length > 0) {
            this.configValues = {};
            for (const key of this.configKeys) {
              if (configData[key] !== undefined) {
                const val = configData[key];
                if (typeof val === 'object' || Array.isArray(val)) {
                  this.configValues[key] = JSON.stringify(val, null, 2);
                } else {
                  this.configValues[key] = String(val);
                }
              } else {
                this.configValues[key] = '';
              }
            }
          }
        },
        async init() {
          if (this.loaded) return;
          this.loaded = true;
          await this.refreshFilesList();
          await this.refreshPlugins();
          this.startWS();
          // load server mode
          await this.refreshState();
          // start a high-resolution animation loop to update nowMs for smooth progress
          const rafTick = () => {
            this.nowMs = Date.now();
            // continue the loop
            // If a swap is due, call pausedRefreshState() once. Use _swapDueHandled
            // to avoid repeated calls while the RAF loop runs at high frequency.
            if (this.state && this.state.next_swap_at && this.nowMs / 1000 >= this.state.next_swap_at) {
              if (!this._swapDueHandled) {
                this._swapDueHandled = true;
              }
            } else {
              // reset the flag when we're not currently past the swap time so
              // the next swap event can trigger the handler again
              this._swapDueHandled = false;
            }
            this._rafId = requestAnimationFrame(rafTick);
          };
          // start the loop
          this._rafId = requestAnimationFrame(rafTick);
          // cleanup on unload
          window.addEventListener('beforeunload', () => {
            if (this._rafId) cancelAnimationFrame(this._rafId);
          });
        },
        log(msg) {
          this.logs.unshift({
            id: Date.now() + Math.random(), // unique key
            time: new Date().toLocaleTimeString(),
            message: msg,
          });
          if (this.logs.length > 200) this.logs.pop();
        },
        async refreshState() {
          try {
            const r = await fetch("/state.json");
            const envelope = await r.json();
            const st = envelope && envelope.state ? envelope.state : envelope;

            // Replace all values directly
            this.state = st || {};
            // Ensure games is always an array
            if (!this.state.games || !Array.isArray(this.state.games)) {
              this.state.games = [];
            }
            // Sync selectedGames from state.games
            this.selectedGames = Array.isArray(this.state.games) ? [...this.state.games] : [];
            this.mainGames = (st.main_games || []).map((e) => ({
              file: e.file,
              extra_files: e.extra_files || [],
            }));
            this.gameInstances = st.game_instances || [];

            // Populate player field on game instances based on player.instance_id
            const playerMap = {};
            if (this.state.players) {
              for (const [name, player] of Object.entries(this.state.players)) {
                if (player.instance_id) {
                  playerMap[player.instance_id] = name;
                }
              }
            }
            for (const inst of this.gameInstances) {
              inst.player = playerMap[inst.id] || "";
            }

            this.interval.min = st.min_interval_secs || 0;
            this.interval.max = st.max_interval_secs || 0;
          } catch (e) {
            this.log("state fetch error: " + e.message);
          }
        },
        async setMode(mode) {
          try {
            const res = await fetch('/api/mode', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode }) });
            if (res.ok) {
              this.toast = 'Mode updated';
              setTimeout(() => this.toast = '', 1500);
            }
          } catch (e) {
            this.log('mode set err: ' + e.message);
          }
        },
        async setupGameMode() {
          try {
            const res = await fetch('/api/mode/setup', { method: 'POST' });
            if (res.ok) {
              const contentType = res.headers.get('content-type');
              this.log('Game mode setup completed');
              this.toast = 'Game mode setup completed';
              setTimeout(() => this.toast = '', 2000);
            } else {
              this.log('Game mode setup failed');
              this.toast = 'Game mode setup failed';
              setTimeout(() => this.toast = '', 2000);
            }
          } catch (e) {
            this.log('Game mode setup error: ' + e.message);
            this.toast = 'Game mode setup error';
            setTimeout(() => this.toast = '', 2000);
          }
        },
        async trigger(path) {
          try {
            const r = await fetch(path, { method: "POST" });
            if (r.ok) {
              const contentType = r.headers.get("content-type");
              if (contentType && contentType.includes("application/json")) {
                const body = await r.json();
                // Replace state directly if it's a full state response
                if (body && (body.players || body.updated_at || Array.isArray(body.games))) {
                  this.state = body;
                  // Ensure games is always an array
                  if (!this.state.games || !Array.isArray(this.state.games)) {
                    this.state.games = [];
                  }
                  // Sync selectedGames from state.games
                  this.selectedGames = Array.isArray(this.state.games) ? [...this.state.games] : [];
                  this.interval.min = this.state.min_interval_secs || 0;
                  this.interval.max = this.state.max_interval_secs || 0;

                  // Populate player field on game instances based on player.instance_id
                  const playerMap = {};
                  if (this.state.players) {
                    for (const [name, player] of Object.entries(this.state.players)) {
                      if (player.instance_id) {
                        playerMap[player.instance_id] = name;
                      }
                    }
                  }
                  for (const inst of this.gameInstances) {
                    inst.player = playerMap[inst.id] || "";
                  }
                }
                // Log action results
                if (body.status) {
                  if (body.status === 'partial_failure') {
                    this.log(`${path} partial failure`);
                    const results = body.swap_results || body.results || [];
                    const dl = body.download_results || [];
                    this.log(`swap results: ${JSON.stringify(results)}`);
                    if (dl && dl.length) this.log(`download results: ${JSON.stringify(dl)}`);
                  } else if (body.status === 'ok') {
                    this.log(`${path} OK`);
                  } else {
                    this.log(`${path} status: ${body.status}`);
                  }
                } else {
                  this.log(`${path} response: ${JSON.stringify(body)}`);
                }
              } else {
                this.log(`${path} OK`);
              }
              this.toast = "Action successful";
            } else {
              this.log(`${path} FAIL`);
              this.toast = "Action failed";
            }
            setTimeout(() => (this.toast = ""), 2000);
          } catch (e) {
            this.log("err " + e.message);
          }
        },
        async refreshFilesList() {
          try {
            const r = await fetch('/files/list.json');
            const raw = await r.json();
            // normalize to array of filename strings (server returns {name,size})
            this.files = (raw || []).map(f => {
              if (!f) return '';
              if (typeof f === 'string') return f;
              return f.name || f.Name || '';
            }).filter(Boolean);
          } catch (e) {
            this.log('files list error: ' + e.message);
          }
        },
        // availableFiles(allowUsedInPrimaryOnly=false)
        // returns filenames from this.files that are not already used as a primary file
        // or extra file in the catalog. If allowUsedInPrimaryOnly is true, then
        // the primary file may be included but extras will exclude any files used
        // as a primary elsewhere.
        availableFiles(allowExtras) {
          // Build a set of files used as primary or extras anywhere in the catalog
          const usedAnywhere = new Set();
          for (const e of this.mainGames) {
            if (e.file) usedAnywhere.add(e.file);
            if (e.extra_files) for (const ex of e.extra_files) usedAnywhere.add(ex);
          }
          if (allowExtras) {
            // For extras dropdown: exclude any file used anywhere (primary or extra)
            // and also exclude the currently selected primary so it's not chosen as its own extra.
            return this.files.filter(f => {
              if (!f) return false;
              if (this.newMain && this.newMain.primary && f === this.newMain.primary) return false;
              return !usedAnywhere.has(f);
            });
          }
          // For primary dropdown: exclude files already used anywhere as primary or extra
          return this.files.filter(f => f && !usedAnywhere.has(f));
        },
        addMainEntry() {
          if (!this.newMain.primary) return;
          const entry = { file: this.newMain.primary, extra_files: Array.isArray(this.newMain.extras) ? this.newMain.extras.slice() : [] };
          // ensure not duplicating primary
          if (this.mainGames.some(e => e.file === entry.file)) {
            this.log('file already in catalog');
            return;
          }
          this.mainGames.push(entry);
          this.newMain.primary = '';
          this.newMain.extras = [];
        },
        removeMainEntry(idx) {
          this.mainGames.splice(idx, 1);
        },
        async saveMainGames() {
          try {
            const payload = { main_games: this.mainGames, game_instances: this.gameInstances };
            const res = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (res.ok) {
              this.log('main games saved');
            } else {
              this.log('save main games failed');
            }
          } catch (e) {
            this.log('save main err: ' + e.message);
          }
        },
        addInstance() {
          if (!this.newInstance.id || !this.newInstance.game) {
            this.log("Please enter both Instance ID and Game file.");
            return;
          }
          const newInst = {
            id: this.newInstance.id,
            game: this.newInstance.game,
            file_state: "none",
            player: "" // New instances don't have assigned players initially
          };
          this.gameInstances.push(newInst); // Add to UI list immediately
          this.saveInstances(); // Persist to server
          this.newInstance = { id: "", game: "" }; // Reset the form
        },
        autofillId() {
          if (this.newInstance.game) {
            // Generate ID from game filename: remove extension and sanitize
            const base = this.newInstance.game.replace(/\.[^/.]+$/, ""); // remove extension
            let cleanName = base.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase();

            // Limit to 20 characters
            if (cleanName.length > 20) {
              cleanName = cleanName.substring(0, 20);
            }

            // Build a set of existing instance IDs
            const existingIDs = new Set();
            for (const inst of this.gameInstances) {
              existingIDs.add(inst.id);
            }

            // Check if base name exists, if not use it directly
            if (!existingIDs.has(cleanName)) {
              this.newInstance.id = cleanName;
              return;
            }

            // Increment counter until we find a free name
            let counter = 1;
            while (true) {
              const candidate = cleanName + "-" + counter;
              if (!existingIDs.has(candidate)) {
                this.newInstance.id = candidate;
                return;
              }
              counter++;
            }
          } else {
            this.newInstance.id = "";
          }
        },
        async saveInstances() {
          try {
            const payload = { main_games: this.mainGames, game_instances: this.gameInstances };
            const res = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (res.ok) {
              this.log('instances saved');
            } else {
              this.log('save instances failed');
            }
          } catch (e) {
            this.log('save instances err: ' + e.message);
          }
        },
        async saveInterval() {
          if (!this.intervalValid) {
            this.log("Invalid interval values");
            return;
          }
          fetch("/api/interval", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              min_interval_secs: this.interval.min,
              max_interval_secs: this.interval.max,
            }),
          }).catch((e) => {
            this.log("interval save err " + e.message);
          });
        },
        async swapPlayer(player, instanceIDOrGame) {
          if (!instanceIDOrGame) return;
          try {
            // If server is in sync mode, send {player, game}, otherwise send {player, instance_id}
            const payload = this.state && this.state.mode === 'sync'
              ? { player, game: instanceIDOrGame }
              : { player, instance_id: instanceIDOrGame };
            const res = await fetch("/api/swap_player", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
          } catch (e) {
            this.log("swap_player err " + e.message);
          }
        },
        async randomSwap(player) {
          if (!player) return;
          try {
            const res = await fetch("/api/random_swap", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ player }),
            });
          } catch (e) {
            this.log("random_swap err " + e.message);
          }
        },
        async swapAll(game) {
          if (!game) return;
          try {
            const res = await fetch("/api/swap_all_to_game", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ game }),
            });
          } catch (e) {
            this.log("swap_all err " + e.message);
          }
        },
        async addPlayer() {
          if (!this.newPlayerName || !this.newPlayerName.trim()) return;
          const playerName = this.newPlayerName.trim();
          try {
            const res = await fetch('/api/add_player', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player: playerName })
            });
            if (res.ok) {
              const body = await res.json().catch(() => null);
              this.log(`Added player: ${playerName}`);
              this.toast = `Player ${playerName} added`;
              setTimeout(() => this.toast = '', 2000);
              this.newPlayerName = ""; // Clear the input
              await this.refreshState(); // Refresh to show the new player
            } else {
              const errorText = await res.text().catch(() => 'unknown error');
              this.log(`/api/add_player failed for ${playerName}: ${errorText}`);
              this.toast = `Failed to add player: ${errorText}`;
              setTimeout(() => this.toast = '', 2000);
            }
          } catch (e) {
            this.log('add_player err ' + e.message);
            this.toast = 'Error adding player';
            setTimeout(() => this.toast = '', 2000);
          }
        },
        async removePlayer(player) {
          if (!player) return;
          if (!confirm(`Remove player '${player}' from session? This will disconnect them.`)) return;
          try {
            const res = await fetch('/api/remove_player', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player })
            });
            if (res.ok) {
              const body = await res.json().catch(() => null);
              this.log(`remove_player: ${player}`);
            } else {
              this.log(`/api/remove_player failed for ${player}`);
            }
          } catch (e) {
            this.log('remove_player err ' + e.message);
          }
        },
        async messagePlayer(player) {
          if (!player) return;
          this.openMessageComposer('player', player);
        },
        async toggleFullscreen(player) {
          if (!player) return;
          await sleep(1000);
          try {
            const res = await fetch('/api/fullscreen_toggle', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player })
            });
            if (res.ok) {
              this.log(`fullscreen toggle sent to ${player}`);
            } else {
              this.log(`/api/fullscreen_toggle failed for ${player}`);
            }
          } catch (e) {
            this.log('fullscreen_toggle err ' + e.message);
          }
        },
        async messageAll() {
          this.openMessageComposer('all');
        },
        startWS() {
          if (this.ws && this.ws.readyState <= 1) {
            // already open or connecting
            return;
          }
          try {
            this.ws = new WebSocket(
              (location.protocol === "https:" ? "wss://" : "ws://") +
              location.host +
              "/ws"
            );
            this.ws.onopen = () => {
              const timestamp = new Date().toLocaleTimeString();
              this.log(`WS Connection: Opened`);
              try {
                // Generate a unique admin name
                const adminName = 'admin_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                const hello = {
                  cmd: "hello_admin",
                  id: String(Date.now()),
                  payload: {
                    name: adminName
                  }
                };
                this.ws.send(JSON.stringify(hello));
                this.log(`Sent admin hello with name: ${adminName}`);
              } catch (e) {
                this.log(`WS hello send error: ${e.message}`);
              }
            };
            this.ws.onclose = () => {
              const timestamp = new Date().toLocaleTimeString();
              this.log(`WS Connection: Closed - Reconnecting in 3s`);
              setTimeout(() => this.startWS(), 3000);
            };
            this.ws.onmessage = (ev) => {
              try {
                const d = JSON.parse(ev.data);
                const timestamp = new Date().toLocaleTimeString();
                this.log(`WS Broadcast: ${d.cmd} ${JSON.stringify(d.payload || {})}`);
                if (d.cmd === "state_update") {
                  this.refreshState();
                  // Update config form values if config data changed
                  if (this.showConfigModal && this.configPlayer) {
                    this.updateConfigFormValues();
                  }
                }
              } catch (e) {
                const timestamp = new Date().toLocaleTimeString();
                this.log(`WS Broadcast Error: ${ev.data} (${e.message})`);
              }
            };
          } catch (e) {
            const timestamp = new Date().toLocaleTimeString();
            this.log(`WS Connection Error: ${e.message}`);
          }
        },
        // Toggle a game in the sync-mode selection list and persist immediately
        async toggleSyncGame(game, checked) {
          if (!this.selectedGames || !Array.isArray(this.selectedGames)) this.selectedGames = [];
          if (checked) {
            if (!this.selectedGames.includes(game)) this.selectedGames.push(game);
          } else {
            this.selectedGames = this.selectedGames.filter(g => g !== game);
          }
          // Immediately persist via POST /api/games using legacy shape { games: [...] }
          try {
            const res = await fetch('/api/games', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ games: this.selectedGames }),
            });
            if (res.ok) {
              this.log('sync games updated');
            } else {
              this.log('failed to save sync games');
            }
          } catch (e) {
            this.log('toggleSyncGame err: ' + e.message);
          }
        },
        // toggle accordion sections; ensure mutual exclusivity
        toggleSection(name) {
          if (name === 'games') {
            this.showGamesExpanded = !this.showGamesExpanded;
            if (this.showGamesExpanded) {
              this.showSavesExpanded = false;
              this.showPluginsExpanded = false;
            }
          } else if (name === 'saves') {
            this.showSavesExpanded = !this.showSavesExpanded;
            if (this.showSavesExpanded) {
              this.showGamesExpanded = false;
              this.showPluginsExpanded = false;
            }
          } else if (name === 'plugins') {
            this.showPluginsExpanded = !this.showPluginsExpanded;
            if (this.showPluginsExpanded) {
              this.showGamesExpanded = false;
              this.showSavesExpanded = false;
            }
          }
          // small timeout to allow layout changes then refresh scrollable lists if needed
          setTimeout(() => {
            // nothing heavy here; future hooks could recalc virtual lists
          }, 100);
        },
        // Plugin management functions
        async refreshPlugins() {
          try {
            const res = await fetch('/api/plugins');
            if (res.ok) {
              const body = await res.json();
              this.plugins = body.plugins || {};
            }
          } catch (e) {
            this.log('refresh plugins err: ' + e.message);
          }
        },
        async showPluginDetails(name) {
          try {
            // Load plugin metadata
            const metaRes = await fetch(`/api/plugins/${encodeURIComponent(name)}`);
            if (metaRes.ok) {
              this.pluginDetails = await metaRes.json() || { name };
            } else {
              this.pluginDetails = { name, description: 'Failed to fetch plugin details' };
            }

            // Load plugin settings
            const settingsRes = await fetch(`/api/plugins/${encodeURIComponent(name)}/settings`);
            if (settingsRes.ok) {
              this.pluginSettings = await settingsRes.json() || { status: 'disabled' };
            } else {
              this.pluginSettings = { status: 'disabled' };
            }

            // Reset new setting fields
            this.newSettingKey = "";
            this.newSettingValue = "";
          } catch (e) {
            this.log('show plugin edit err: ' + e.message);
            this.pluginDetails = { name, description: 'Error: ' + e.message };
            this.pluginSettings = { status: 'disabled' };
          }
          this.pluginDetailsVisible = true;
        },
        addSetting() {
          if (!this.newSettingKey || this.newSettingKey.trim() === '') {
            this.log('Setting key cannot be empty');
            return;
          }
          if (this.newSettingKey === 'status') {
            this.log('Cannot add status setting (already exists)');
            return;
          }
          // Initialize pluginSettings if needed
          if (!this.pluginSettings || typeof this.pluginSettings !== 'object') {
            this.pluginSettings = { status: 'disabled' };
          }
          this.pluginSettings[this.newSettingKey.trim()] = this.newSettingValue || '';
          this.newSettingKey = "";
          this.newSettingValue = "";
        },
        // Helper functions for multiselect settings
        isMultiselectOptionSelected(settingKey, option) {
          if (!this.pluginSettings || !this.pluginSettings[settingKey]) {
            return false;
          }
          const currentValue = this.pluginSettings[settingKey];
          if (!currentValue || typeof currentValue !== 'string') {
            return false;
          }
          // Split comma-separated values and check if option is included
          const selectedValues = currentValue.split(',').map(v => v.trim()).filter(v => v);
          return selectedValues.includes(option);
        },
        updateMultiselectSetting(settingKey, option, checked) {
          if (!this.pluginSettings) {
            this.pluginSettings = { status: 'disabled' };
          }
          const currentValue = this.pluginSettings[settingKey] || '';
          const selectedValues = currentValue.split(',').map(v => v.trim()).filter(v => v);

          if (checked) {
            // Add option if not already present
            if (!selectedValues.includes(option)) {
              selectedValues.push(option);
            }
          } else {
            // Remove option
            const index = selectedValues.indexOf(option);
            if (index > -1) {
              selectedValues.splice(index, 1);
            }
          }

          // Update the setting with comma-separated values
          this.pluginSettings[settingKey] = selectedValues.join(',');
        },
        async savePluginSettings() {
          if (!this.pluginDetails || !this.pluginDetails.name) {
            this.log('No plugin selected');
            return;
          }
          try {
            const res = await fetch(`/api/plugins/${encodeURIComponent(this.pluginDetails.name)}/settings`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(this.pluginSettings)
            });
            if (res.ok) {
              this.log(`Settings saved for plugin ${this.pluginDetails.name}`);
              this.toast = 'Settings saved';
              setTimeout(() => this.toast = '', 2000);
              await this.refreshPlugins();
              this.pluginDetailsVisible = false;
            } else {
              const error = await res.text().catch(() => 'save failed');
              this.log(`Failed to save settings: ${error}`);
              this.toast = 'Failed to save settings';
              setTimeout(() => this.toast = '', 2000);
            }
          } catch (e) {
            this.log('save settings err: ' + e.message);
            this.toast = 'Error saving settings';
            setTimeout(() => this.toast = '', 2000);
          }
        },
        async deletePlugin(name) {
          if (!confirm(`Delete plugin '${name}' from server? This cannot be undone.`)) return;
          try {
            const res = await fetch(`/api/plugins/${encodeURIComponent(name)}`, { method: 'DELETE' });
            if (res.ok) {
              this.log(`Deleted plugin ${name}`);
              await this.refreshPlugins();
            } else {
              const msg = await res.text().catch(() => 'delete failed');
              this.log(`Failed to delete plugin ${name}: ${msg}`);
            }
          } catch (e) {
            this.log('delete plugin err: ' + e.message);
          }
        },
        async togglePlugin(name, enable) {
          try {
            // Fetch current settings
            const getRes = await fetch(`/api/plugins/${encodeURIComponent(name)}/settings`);
            if (!getRes.ok) {
              this.log(`Failed to fetch settings for plugin ${name}`);
              return;
            }

            const currentSettings = await getRes.json() || { status: 'disabled' };

            // Toggle the status
            const newSettings = { ...currentSettings };
            newSettings.status = enable ? 'enabled' : 'disabled';

            // Update settings using the settings API
            const res = await fetch(`/api/plugins/${encodeURIComponent(name)}/settings`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(newSettings)
            });

            if (res.ok) {
              const action = enable ? 'enabled' : 'disabled';
              this.log(`Plugin ${name} ${action}`);
              await this.refreshPlugins();
            } else {
              const error = await res.text().catch(() => 'update failed');
              this.log(`Failed to update plugin ${name}: ${error}`);
            }
          } catch (e) {
            this.log(`Plugin toggle err: ` + e.message);
          }
        },
        async reloadPlugin(name) {
          try {
            const res = await fetch(`/api/plugins/${encodeURIComponent(name)}/reload`, {
              method: 'POST'
            });
            if (res.ok) {
              this.log(`Plugin ${name} reload requested`);
            } else {
              const error = await res.text().catch(() => 'reload failed');
              this.log(`Failed to reload plugin ${name}: ${error}`);
            }
          } catch (e) {
            this.log(`Plugin reload err: ` + e.message);
          }
        },
        async openRomsFolder() {
          try {
            const res = await fetch('/api/open_roms_folder', {
              method: 'POST'
            });
            if (res.ok) {
              this.log('Opening roms folder');
              this.toast = 'Roms folder opened';
            } else {
              const error = await res.text().catch(() => 'failed');
              this.log('Failed to open roms folder: ' + error);
              this.toast = 'Failed to open roms folder';
            }
          } catch (e) {
            this.log('Open roms folder error: ' + e.message);
            this.toast = 'Error opening roms folder';
          }
          setTimeout(() => this.toast = '', 2000);
        },
        async openPluginsFolder() {
          try {
            const res = await fetch('/api/open_plugins_folder', {
              method: 'POST'
            });
            if (res.ok) {
              this.log('Opening plugins folder');
              this.toast = 'Plugins folder opened';
            } else {
              const error = await res.text().catch(() => 'failed');
              this.log('Failed to open plugins folder: ' + error);
              this.toast = 'Failed to open plugins folder';
            }
          } catch (e) {
            this.log('Open plugins folder error: ' + e.message);
            this.toast = 'Error opening plugins folder';
          }
          setTimeout(() => this.toast = '', 2000);
        },
        // Message composer functions
        openMessageComposer(target, playerName = null) {
          this.messageTarget = { type: target, player: playerName };
          this.showMessageComposer = true;
        },
        closeMessageComposer() {
          this.showMessageComposer = false;
          // Keep values for next time - don't reset
          this.messageTarget = null;
        },
        resetMessageComposer() {
          this.messageComposer = {
            text: "",
            duration: 3,
            x: 10,
            y: 10,
            fontsize: 12,
            fg: "#FFFFFF",
            bg: "#000000"
          };
        },
        async sendComposedMessage() {
          if (!this.messageComposer.text.trim()) return;

          try {
            const payload = {
              message: this.messageComposer.text,
              duration: this.messageComposer.duration,
              x: this.messageComposer.x,
              y: this.messageComposer.y,
              fontsize: this.messageComposer.fontsize,
              fg: this.messageComposer.fg,
              bg: this.messageComposer.bg
            };

            let url, logMsg;
            if (this.messageTarget.type === 'player') {
              url = '/api/message_player';
              payload.player = this.messageTarget.player;
              logMsg = `message sent to ${this.messageTarget.player}`;
            } else {
              url = '/api/message_all';
              logMsg = 'message sent to all players';
            }

            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (res.ok) {
              this.log(logMsg + ': "' + this.messageComposer.text + '"');
              // Don't close modal - keep it open for more messages
              // Clear just the text field for convenience
              this.messageComposer.text = "";
            } else {
              this.log('Message send failed');
            }
          } catch (e) {
            this.log('Message send error: ' + e.message);
          }
        },
        // Config management functions
        async checkPlayerConfig(playerName) {
          if (!playerName) return;

          this.configPlayer = playerName;
          this.configValues = {};
          this.configKeys = this.state.config_keys || [];

          try {
            // Request config from player
            const res = await fetch('/api/check_player_config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player: playerName })
            });

            if (res.ok) {
              this.log(`Config check requested for ${playerName}`);
              // Clear any existing config values and show modal
              // Values will be populated when state updates arrive
              this.showConfigModal = true;
              // Try to populate form immediately in case data is already available
              setTimeout(() => this.updateConfigFormValues(), 100);
            } else {
              const error = await res.text().catch(() => 'request failed');
              this.log(`Failed to request config for ${playerName}: ${error}`);
              this.closeConfigModal();
            }
          } catch (e) {
            this.log('Config check error: ' + e.message);
            this.closeConfigModal();
          }
        },
        closeConfigModal() {
          this.showConfigModal = false;
          this.configPlayer = "";
          this.configValues = {};
        },
        async savePlayerConfig() {
          if (!this.configPlayer) return;

          const playerConfigValues = this.getPlayerConfigValues();
          if (!playerConfigValues) return;

          // Build object with only the changed values
          const updates = {};
          for (const key of this.configKeys) {
            if (this.configValues[key] !== undefined) {
              let newValue;
              // Try to parse as JSON first (for objects/arrays), otherwise use as string
              try {
                newValue = JSON.parse(this.configValues[key]);
              } catch {
                // If JSON parsing fails, treat as string/number/boolean
                const val = this.configValues[key];
                if (val === 'true') {
                  newValue = true;
                } else if (val === 'false') {
                  newValue = false;
                } else if (!isNaN(val) && val !== '') {
                  newValue = Number(val);
                } else {
                  newValue = val;
                }
              }

              // Only include if the value actually changed
              const currentValue = playerConfigValues[key];
              if (JSON.stringify(currentValue) !== JSON.stringify(newValue)) {
                updates[key] = newValue;
              }
            }
          }

          if (Object.keys(updates).length === 0) {
            this.log('No config changes detected');
            this.closeConfigModal();
            return;
          }

          // Serialize updates to JSON
          const updatesJson = JSON.stringify(updates);

          if (!confirm(`This will update ${this.configPlayer}'s BizHawk config. You will need to restart BizHawk manually for changes to take effect. Continue?`)) {
            return;
          }

          try {
            const res = await fetch('/api/update_player_config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ player: this.configPlayer, config: updatesJson })
            });

            if (res.ok) {
              this.log(`Config update sent to ${this.configPlayer}`);
              this.toast = 'Config updated - please restart BizHawk manually';
              setTimeout(() => this.toast = '', 3000);
              this.closeConfigModal();
            } else {
              const error = await res.text().catch(() => 'update failed');
              this.log(`Failed to update config for ${this.configPlayer}: ${error}`);
              this.toast = 'Failed to update config';
              setTimeout(() => this.toast = '', 2000);
            }
          } catch (e) {
            this.log('Config update error: ' + e.message);
            this.toast = 'Error updating config';
            setTimeout(() => this.toast = '', 2000);
          }
        },
        // Drag and Drop Functions
        onDragStart(event, playerName, type) {
          this.draggedPlayer = playerName;
          this.draggedType = type;
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', playerName);
          event.target.classList.add('opacity-50');
        },
        onDragEnd(event) {
          this.draggedPlayer = null;
          this.draggedType = null;
          event.target.classList.remove('opacity-50');
          // Remove all drag-over highlights
          document.querySelectorAll('.drag-over').forEach(el => {
            el.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');
          });
        },
        onDragOver(event) {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'move';
          event.currentTarget.classList.add('drag-over');
          // Add specific visual feedback based on element type
          if (event.currentTarget.classList.contains('border-dashed')) {
            event.currentTarget.classList.add('bg-blue-900/30', 'border-blue-400');
          } else {
            event.currentTarget.classList.add('bg-blue-900/50', 'border-blue-500', 'scale-105');
          }
        },
        onDragLeave(event) {
          event.currentTarget.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');
        },
        async onDrop(event, targetId, targetType) {
          event.preventDefault();
          event.currentTarget.classList.remove('drag-over', 'bg-blue-900/50', 'border-blue-500', 'bg-blue-900/30', 'border-blue-400', 'scale-105');

          if (!this.draggedPlayer) return;

          const playerName = this.draggedPlayer;

          try {
            if (targetType === 'instance') {
              await this.handlePlayerToInstanceDrop(playerName, targetId);
            } else if (targetType === 'unassigned') {
              await this.handlePlayerToUnassignedDrop(playerName);
            }
          } catch (e) {
            this.log('Drop error: ' + e.message);
          }

          this.draggedPlayer = null;
          this.draggedType = null;
        },
        async handlePlayerToInstanceDrop(playerName, instanceId) {
          // Find the target instance
          const targetInstance = this.gameInstances.find(inst => inst.id === instanceId);

          if (!targetInstance) {
            // Instance doesn't exist - check if we need to create one
            const unassignedPlayers = this.unassignedPlayers;
            if (unassignedPlayers.length > 0) {
              // Create a new instance for the first unassigned player
              const firstUnassigned = unassignedPlayers[0];
              this.log(`Creating new instance for unassigned player ${firstUnassigned}`);

              // Generate a new instance ID based on the game file
              const gameFile = this.mainGamesList[0] || 'unknown';
              const base = gameFile.replace(/\.[^/.]+$/, ""); // remove extension
              const newInstanceId = base.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase() + '_' + Date.now();

              // Add the new instance
              const newInstance = {
                id: newInstanceId,
                game: gameFile,
                file_state: "none",
                player: firstUnassigned
              };

              this.gameInstances.push(newInstance);
              await this.saveInstances();

              // Now swap the dragged player to this new instance
              if (firstUnassigned !== playerName) {
                await this.swapPlayer(playerName, newInstanceId);
              }
            }
            return;
          }

          // Find the current instance of the dragged player
          const currentInstance = this.gameInstances.find(inst => inst.player === playerName);

          if (targetInstance.player) {
            // Target instance has a player - swap them
            const targetPlayer = targetInstance.player;

            if (currentInstance) {
              // Both players have instances - swap them
              this.log(`Swapping ${playerName} with ${targetPlayer}`);
              await this.swapPlayer(playerName, instanceId);
              // The swap should handle both directions
            } else {
              // Dragged player is unassigned, target has player - move to empty spot
              this.log(`Moving unassigned ${playerName} to instance ${instanceId}`);
              await this.swapPlayer(playerName, instanceId);
            }
          } else {
            // Target instance is empty - just assign the player
            this.log(`Assigning ${playerName} to empty instance ${instanceId}`);
            await this.swapPlayer(playerName, instanceId);
          }
        },
        async handlePlayerToUnassignedDrop(playerName) {
          // Find if player is currently assigned to an instance
          const currentInstance = this.gameInstances.find(inst => inst.player === playerName);

          if (currentInstance) {
            // Player is assigned - unassign them by swapping to empty instance
            this.log(`Unassigning ${playerName} from instance ${currentInstance.id}`);
            // For unassignment, we need to call swap with an empty instance_id
            // This should be handled by the server when instance_id is empty or null
            await this.swapPlayer(playerName, '');
          } else {
            // Player is already unassigned - do nothing
            this.log(`${playerName} is already unassigned`);
          }
        },
        async addCompletedGame(playerName, game) {
          if (!game || !playerName) return;
          try {
            const res = await fetch(`/api/players/${encodeURIComponent(playerName)}/completed_games`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ game })
            });
            if (res.ok) {
              this.log(`Added completed game ${game} for ${playerName}`);
              await this.refreshState();
            } else {
              this.log(`Failed to add completed game: ${res.statusText}`);
            }
          } catch (e) {
            this.log('addCompletedGame err: ' + e.message);
          }
        },
        async removeCompletedGame(playerName, game) {
          if (!game || !playerName) return;
          try {
            const res = await fetch(`/api/players/${encodeURIComponent(playerName)}/completed_games?game=${encodeURIComponent(game)}`, {
              method: 'DELETE'
            });
            if (res.ok) {
              this.log(`Removed completed game ${game} for ${playerName}`);
              await this.refreshState();
            } else {
              this.log(`Failed to remove completed game: ${res.statusText}`);
            }
          } catch (e) {
            this.log('removeCompletedGame err: ' + e.message);
          }
        },
        async addCompletedInstance(playerName, instance) {
          if (!instance || !playerName) return;
          try {
            const res = await fetch(`/api/players/${encodeURIComponent(playerName)}/completed_instances`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ instance })
            });
            if (res.ok) {
              this.log(`Added completed instance ${instance} for ${playerName}`);
              await this.refreshState();
            } else {
              this.log(`Failed to add completed instance: ${res.statusText}`);
            }
          } catch (e) {
            this.log('addCompletedInstance err: ' + e.message);
          }
        },
        async removeCompletedInstance(playerName, instance) {
          if (!instance || !playerName) return;
          try {
            const res = await fetch(`/api/players/${encodeURIComponent(playerName)}/completed_instances?instance=${encodeURIComponent(instance)}`, {
              method: 'DELETE'
            });
            if (res.ok) {
              this.log(`Removed completed instance ${instance} for ${playerName}`);
              await this.refreshState();
            } else {
              this.log(`Failed to remove completed instance: ${res.statusText}`);
            }
          } catch (e) {
            this.log('removeCompletedInstance err: ' + e.message);
          }
        },
        async markGameCompletedForAll(game) {
          if (!game) return;
          try {
            const res = await fetch(`/api/games/${encodeURIComponent(game)}/mark_completed_all`, {
              method: 'POST'
            });
            if (res.ok) {
              this.log(`Marked game ${game} as completed for all players`);
              await this.refreshState();
            } else {
              this.log(`Failed to mark game as completed: ${res.statusText}`);
            }
          } catch (e) {
            this.log('markGameCompletedForAll err: ' + e.message);
          }
        },
        async markInstanceCompletedForAll(instance) {
          if (!instance) return;
          try {
            const res = await fetch(`/api/instances/${encodeURIComponent(instance)}/mark_completed_all`, {
              method: 'POST'
            });
            if (res.ok) {
              this.log(`Marked instance ${instance} as completed for all players`);
              await this.refreshState();
            } else {
              this.log(`Failed to mark instance as completed: ${res.statusText}`);
            }
          } catch (e) {
            this.log('markInstanceCompletedForAll err: ' + e.message);
          }
        },
        async removeAllCompletions() {
          if (!confirm('Remove all completed games and instances for all players? This cannot be undone.')) return;
          try {
            const res = await fetch('/api/players/remove_all_completions', {
              method: 'POST'
            });
            if (res.ok) {
              this.log('Removed all completions for all players');
              await this.refreshState();
            } else {
              this.log(`Failed to remove all completions: ${res.statusText}`);
            }
          } catch (e) {
            this.log('removeAllCompletions err: ' + e.message);
          }
        },
      };
    }
  </script>
</body>

</html>